/**************************************************************************************************
    文 件 名：demo.pc
    代码作者：DeffPuzzL
    编写版本：
    创建日期：2016-07-14
    功能描述：demo实现业务模块
 **************************************************************************************************/
#include    "algo.h"
#include    "vdata_load.h"

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
#include    "tbl_order_succ.h"
EXEC SQL END DECLARE SECTION;

/**************************************************************************************************
    方法定义
 **************************************************************************************************/
CLoad::stEvent CLoad::m_stEvent[] =
{
//  {"unload",             &CLoad::vUnloadTxn },
    {"unqpay",             &CLoad::vUnloadQuikPay },
    {"load",               &CLoad::vLoadToOrder },
    { "", NULL }
};

/**************************************************************************************************
    函 数 名：CLoad()
    功能描述：构造函数
    返回说明：
 **************************************************************************************************/
CLoad::CLoad()
{

}

/**************************************************************************************************
    函 数 名：~CLoad()
    功能描述：析构函数
    返回说明：
 **************************************************************************************************/
CLoad::~CLoad()
{


}

/**************************************************************************************************
    函 数 名：lRunObject(char* in_szClass, char* in_szAction)
    功能描述：运行类中的方法
    返回说明：
        RC_SUCC         --成功
        RC_FAIL         --失败
 **************************************************************************************************/
long    CLoad::lRunObject(char *in_szClass, char *in_szAction)
{
    int     i = 0;
    char    *p, szAction[256];

    memset(szAction, 0, sizeof(szAction));

    if ((p = strstr(in_szAction, "__")) != NULL)
    {
        strncpy(szAction, in_szAction, p - in_szAction);
    }
    else
    {
        strcpy(szAction, in_szAction);
    }

    while (0 != strcmp(m_stEvent[i].m_szName, ""))
    {
        if (0 == strcmp(m_stEvent[i].m_szName, szAction))
        {
            (this->*m_stEvent[i].m_pEvent)();
            return RC_SUCC;
        }

        i++;
    }

    SYSError(RET_SYSTEM, "组件(%s)的事件(%s)没注册", in_szClass, in_szAction);
    return RC_FAIL;
}

/**************************************************************************************************
    函 数 名：vUnloadTxn()
    功能描述：
    返回说明：
        无
 **************************************************************************************************/
void    CLoad::vUnloadTxn()
{
    EXEC SQL BEGIN DECLARE SECTION;
    TOrderSucc    stOrder;
    char        szDone[2], szFile[512];
    char        szDate[9], szNum[5], szFlag[2];
    EXEC SQL END DECLARE SECTION;
    long        lCount = 0;
    FILE        *fp = NULL;
    GCts        *pstCts = (GCts *)pGetGloble();

    memset(szNum, 0, sizeof(szNum));
    memset(szDate, 0, sizeof(szDate));
    memset(szFile, 0, sizeof(szFile));
    memset(szFlag, 0, sizeof(szFlag));
    memset(szDone, 0, sizeof(szDone));
    memset(&stOrder, 0, sizeof(TOrderSucc));
    IBPgetstring("BAT_NUM", szNum, "批次编号");
    IBPgetstring("BAT_DATE", szDate, "清算日期");
    if(IBPIserr())
        return ;

    szFlag[0] = EXPORT_TXN_NULL;
    szDone[0] = EXPORT_TXN_DONE;
    snprintf(szFile, sizeof(szFile), "%s/pool/VDATA%s_%s.txt", getenv("FILEDIR"), szDate, szNum);
    if (!(fp = fopen(szFile, "wb")))
    {
        SYSError(RET_SYSTEM, "打开文件(%s)失败, err:(%d)(%s)", szFile, errno, strerror(errno));
        return ;
    }

    IBPrace("开始导出交易流水(%s)批次(%s), 导出文件:%s", szDate, szNum, szFile);

    if(RC_SUCC != lDbsConnect(DBS_TXN))
    {
        SYSError(RET_DATABASE, "连接代扣系统数据库失败, err:(%d)(%s)", SQLCODE, sDbsError())
        return ;
    }

    EXEC SQL DECLARE Cur_payment_order CURSOR FOR 
        SELECT ID, SEQ_ID, DISC_CYCLE, CHANNEL_ID, BANK_CODE, PAY_TYPE, 
            TO_CHAR(TRANS_DATE, 'YYYYMMDD'), TO_CHAR(TRANS_DATE, 'HHMISS'),
            AMOUNT, BANK_CARD_NO, USER_NAME, BANK_ACC_TYPE, BANK_FULL_NAME, 
            BANK_BRANCH_NAME, BANK_AREACODE, CNAPS_NO, CNAPS_BANKNO, CURRENCY, 
            REMARK, STATUS, BANK_RESPCODE, BANK_RESPMSG, VID_RESPCODE, VID_RESPMSG,
            EXT_PROPERTIES, CUSTOMER_CARD_TYPE, APP_CODE, BRH_CODE, MERT_ID, 
            MERT_NAME, CERT_TYPE, CERT_NO, MOBILE_NO, ORDER_ID, PRODUCT_CODE, 
            PRODUCT_NAME, PAY_KIND, BANK_SEQ_ID, BATCH_SEQ_ID
    FROM TBL_DKPAYMENT_ORDER where TO_CHAR(TRANS_DATE, 'YYYYMMDD') < :szDate 
        AND SUBSTR(CHECK_STATUS, 2, 1) = :szFlag;

    EXEC SQL OPEN Cur_payment_order;
    if(SQLCODE)
    {
        fclose(fp);
        SYSError(RET_DATABASE, "打开游标失败, err:(%d)(%s)", SQLCODE, sDbsError());
        return ;
    }

    while (1)
    {
        memset(&stOrder, 0, sizeof(TOrderSucc));
        EXEC SQL FETCH Cur_payment_order INTO
            :stOrder.id, :stOrder.seq_order, :stOrder.disc_cycle, :stOrder.channel_no,
            :stOrder.bank_code, :stOrder.pay_type, :stOrder.tx_date, :stOrder.tx_time, 
            :stOrder.tx_amt, :stOrder.bank_card_no, :stOrder.user_name, :stOrder.bank_acc_type,
            :stOrder.bank_full_name, :stOrder.bank_branch_name, :stOrder.bank_areacode,
            :stOrder.cnaps_no, :stOrder.cnaps_bankno, :stOrder.currency, :stOrder.remark,
            :stOrder.status, :stOrder.bank_respcode, :stOrder.bank_respmsg, :stOrder.vid_respcode, 
            :stOrder.vid_respmsg, :stOrder.ext_properties, :stOrder.card_type, :stOrder.app_code, 
            :stOrder.brh_code, :stOrder.mert_no, :stOrder.mert_nm, :stOrder.cert_type, 
            :stOrder.cert_no, :stOrder.mobile_no, :stOrder.order_id, :stOrder.product_code, 
            :stOrder.product_name, :stOrder.pay_kind, :stOrder.bank_seqno, :stOrder.batch_seqno;
        if(SQLERR)
        {
            SYSError(RET_DATABASE, "导出代扣流水失败, err:(%d)(%s)", SQLCODE, sDbsError());
            break;
        }
        if(SQLNOTFOUND)
            break;

        ++ lCount;
        sTrimRight(stOrder.id);
        sTrimRight(stOrder.seq_order);
        sTrimRight(stOrder.bank_code);
        sTrimRight(stOrder.pay_type);
        sTrimRight(stOrder.tx_date);
        sTrimRight(stOrder.tx_time);
        sTrimRight(stOrder.bank_card_no);
        sTrimRight(stOrder.user_name);
        sTrimRight(stOrder.bank_acc_type);
        sTrimRight(stOrder.bank_full_name);
        sTrimRight(stOrder.bank_branch_name);
        sTrimRight(stOrder.bank_areacode);
        sTrimRight(stOrder.cnaps_no);
        sTrimRight(stOrder.cnaps_bankno);
        sTrimRight(stOrder.currency);
        sTrimRight(stOrder.remark);
        sTrimRight(stOrder.status);
        sTrimRight(stOrder.bank_respcode);
        sTrimRight(stOrder.bank_respmsg);
        sTrimRight(stOrder.vid_respcode);
        sTrimRight(stOrder.vid_respmsg);
        sTrimRight(stOrder.ext_properties);
        sTrimRight(stOrder.app_code);
        sTrimRight(stOrder.brh_code);
        sTrimRight(stOrder.mert_no);
        sTrimRight(stOrder.mert_nm);
        sTrimRight(stOrder.cert_no);
        sTrimRight(stOrder.mobile_no);
        sTrimRight(stOrder.order_id);
        sTrimRight(stOrder.bank_seqno);
        sTrimRight(stOrder.batch_seqno);
        sTrimRight(stOrder.product_code);
        sTrimRight(stOrder.product_name);

        fwrite(&stOrder, sizeof(TOrderSucc), 1, fp);
    }
    EXEC SQL CLOSE Cur_payment_order;
    fclose(fp);

    EXEC SQL UPDATE tbl_dkpayment_order SET
        CHECK_STATUS = SUBSTR(CHECK_STATUS, 1, 1) || :szDone
    WHERE TO_CHAR(TRANS_DATE, 'YYYYMMDD') < :szDate 
        AND substr(CHECK_STATUS, 2, 1) = :szFlag;
    if(SQL_UD_ERR)
    {
        SYSError(RET_DATABASE, "更新流水导出标识失败, err:(%d)(%s)", SQLCODE, sDbsError());
        EXEC SQL ROLLBACK WORK;
        vDbsDisconnect();
        return ;
    }

    EXEC SQL COMMIT WORK;
    vDbsDisconnect();

    IBPrace("导出交易流水(%s)批次(%s), 导出流水(%ld)条", szDate, szNum, lCount);

    return ;
}


/**************************************************************************************************
    函 数 名：vUnloadQPay()
    功能描述：
    返回说明：
        无
 **************************************************************************************************/
void    CLoad::vUnloadQuikPay()
{
    EXEC SQL BEGIN DECLARE SECTION;
    TOrderSucc  stOrder;
    char        szDone[2], szFile[512];
    char        szDate[9], szNum[5], szFlag[2];
    EXEC SQL END DECLARE SECTION;
    long        lCount = 0;
    FILE        *fp = NULL;
    GCts        *pstCts = (GCts *)pGetGloble();

    memset(szNum, 0, sizeof(szNum));
    memset(szDate, 0, sizeof(szDate));
    memset(szFile, 0, sizeof(szFile));
    memset(szFlag, 0, sizeof(szFlag));
    memset(szDone, 0, sizeof(szDone));
    memset(&stOrder, 0, sizeof(TOrderSucc));
    IBPgetstring("BAT_NUM", szNum, "批次编号");
    IBPgetstring("BAT_DATE", szDate, "清算日期");
    if(IBPIserr())
        return ;

    szFlag[0] = EXPORT_TXN_NULL;
    szDone[0] = EXPORT_TXN_DONE;
    snprintf(szFile, sizeof(szFile), "%s/pool/VDATA%s_%s.txt", getenv("FILEDIR"), szDate, szNum);
    if (!(fp = fopen(szFile, "wb")))
    {
        SYSError(RET_SYSTEM, "打开文件(%s)失败, err:(%d)(%s)", szFile, errno, strerror(errno));
        return ;
    }

    IBPrace("开始导出交易流水(%s)批次(%s), 导出文件:%s", szDate, szNum, szFile);

    if(RC_SUCC != lDbsConnect(DBS_TXN))
    {
        SYSError(RET_DATABASE, "连接代扣系统数据库失败, err:(%d)(%s)", SQLCODE, sDbsError())
        return ;
    }

    EXEC SQL DECLARE Cur_quickpay_order CURSOR FOR 
        SELECT ID, CHANNEL_REQ_ID, DISC_CYCLE, CHANNEL_ID, TX_CODE, TX_DATE, 
			TO_CHAR(CREATE_TIME, 'HHMISS'), TRANS_AMT, ACCT_NO, ACCT_NM, CURRENCY, 
			STATUS, CHANNEL_RESPCODE, CHANNEL_RESPMSG, VID_RESPCODE, VID_RESPMSG,
            CARD_TYPE, CHANNEL_MCHT_NO, BRH_NO, MCHT_NO, MCHT_NAME, CERT_TYPE, CERT_NO, 
			PHONE_NO, OUT_ORDER_NO, PRODUCT_ID, PRODUCT_NAME, EXT_PROPERTIES
    FROM TBL_QUICKPAY_ORDER where TX_DATE < :szDate AND SUBSTR(EXPORT_FLAG, 2, 1) = :szFlag;

    EXEC SQL OPEN Cur_quickpay_order;
    if(SQLCODE)
    {
        fclose(fp);
        SYSError(RET_DATABASE, "打开游标失败, err:(%d)(%s)", SQLCODE, sDbsError());
        return ;
    }

    while (1)
    {
        memset(&stOrder, 0, sizeof(TOrderSucc));
        EXEC SQL FETCH Cur_quickpay_order INTO
            :stOrder.id, :stOrder.seq_order, :stOrder.disc_cycle, :stOrder.channel_no,
            :stOrder.pay_type, :stOrder.tx_date, :stOrder.tx_time, :stOrder.tx_amt, 
			:stOrder.bank_card_no, :stOrder.user_name, :stOrder.currency, :stOrder.status, 
			:stOrder.bank_respcode, :stOrder.bank_respmsg, :stOrder.vid_respcode, 
            :stOrder.vid_respmsg, :stOrder.card_type, :stOrder.app_code, 
            :stOrder.brh_code, :stOrder.mert_no, :stOrder.mert_nm, :stOrder.cert_type, 
            :stOrder.cert_no, :stOrder.mobile_no, :stOrder.order_id, :stOrder.product_code, 
            :stOrder.product_name, :stOrder.ext_properties;
        if(SQLERR)
        {
            SYSError(RET_DATABASE, "导出代扣流水失败, err:(%d)(%s)", SQLCODE, sDbsError());
            break;
        }
        if(SQLNOTFOUND)
            break;

        ++ lCount;
        sTrimRight(stOrder.id);
        sTrimRight(stOrder.seq_order);
        sTrimRight(stOrder.channel_no);
        sTrimRight(stOrder.pay_type);
        sTrimRight(stOrder.tx_date);
        sTrimRight(stOrder.tx_time);
        sTrimRight(stOrder.bank_card_no);
        sTrimRight(stOrder.user_name);
        sTrimRight(stOrder.currency);
        sTrimRight(stOrder.status);
        sTrimRight(stOrder.bank_respcode);
        sTrimRight(stOrder.bank_respmsg);
        sTrimRight(stOrder.vid_respcode);
        sTrimRight(stOrder.vid_respmsg);
        sTrimRight(stOrder.ext_properties);
        sTrimRight(stOrder.app_code);
        sTrimRight(stOrder.brh_code);
        sTrimRight(stOrder.mert_no);
        sTrimRight(stOrder.mert_nm);
        sTrimRight(stOrder.cert_no);
        sTrimRight(stOrder.mobile_no);
        sTrimRight(stOrder.order_id);
        sTrimRight(stOrder.product_code);
        sTrimRight(stOrder.product_name);

        fwrite(&stOrder, sizeof(TOrderSucc), 1, fp);
    }
    EXEC SQL CLOSE Cur_quickpay_order;
    fclose(fp);

    EXEC SQL UPDATE TBL_QUICKPAY_ORDER SET
        EXPORT_FLAG = SUBSTR(EXPORT_FLAG, 1, 1) || :szDone
    WHERE TX_DATE < :szDate AND substr(EXPORT_FLAG, 2, 1) = :szFlag;
    if(SQL_UD_ERR)
    {
        SYSError(RET_DATABASE, "更新流水导出标识失败, err:(%d)(%s)", SQLCODE, sDbsError());
        EXEC SQL ROLLBACK WORK;
        vDbsDisconnect();
        return ;
    }

    EXEC SQL COMMIT WORK;
    vDbsDisconnect();

    IBPrace("导出交易流水(%s)批次(%s), 导出流水(%ld)条", szDate, szNum, lCount);

    return ;
}

/**************************************************************************************************
    函 数 名：lLoadFromFile(char *pszFile)
    功能描述：
    返回说明：
        无
 **************************************************************************************************/
long    CLoad::lLoadFromFile(char *pszFile, char *pszDate, char *pszNum)
{
    EXEC SQL BEGIN DECLARE SECTION;
    TOrderSucc  stOrder;
	char		szTime[15], szDate[9];
    EXEC SQL END DECLARE SECTION;
    long        lCount = 0;
    FILE        *fp = NULL;

    memset(szTime, 0, sizeof(szTime));
    memset(szDate, 0, sizeof(szDate));
    memset(&stOrder, 0, sizeof(TOrderSucc));
	memcpy(szTime, sGetCurrentTime(), 14);
	strncpy(szDate, sGetChgDate(pszDate, -1), 8);
    if(NULL == (fp = fopen(pszFile, "rb")))
    {
        SYSError(RET_SYSTEM, "打开文件(%s)失败, %s", pszFile, strerror(errno));
        return RC_FAIL;
    }

	EXEC SQL DELETE FROM TBL_ORDER_SUCC WHERE TX_DATE = :szDate;
    EXEC SQL COMMIT WORK;

    while(fread((char *)&stOrder, sizeof(TOrderSucc), 1, fp))
    {
        strncpy(stOrder.create_time, szTime, sizeof(stOrder.create_time) - 1);
        if((!strcmp(stOrder.status, "success")) && (!strcmp(stOrder.pay_type, "vidata.quick.backpay")))
        {
            stOrder.result_flag[0] = TXN_SUCC_INIT;
            snprintf(stOrder.cup_key, sizeof(stOrder.cup_key), "%s%s", stOrder.channel_no, stOrder.seq_order);
        }
        else
            stOrder.result_flag[0] = TXN_SUCC_REVERSED;

        EXEC SQL INSERT INTO TBL_ORDER_SUCC VALUES (:stOrder);
        if(SQLCODE)
        {
            fclose(fp);
            SYSError(RET_DATABASE, "新增流水(%s)失败, %s", stOrder.id, sDbsError());
            return RC_FAIL;
        }

        if(0 == ++ lCount % 2000)
            EXEC SQL COMMIT WORK;
    }
    fclose(fp);
    EXEC SQL COMMIT WORK;
    IBPrace("开始导入文件(%s)流水笔数:%d", pszFile, lCount);

	return RC_SUCC;
}

/**************************************************************************************************
    函 数 名：vLoadToOrder()
    功能描述：
    返回说明：
        无
 **************************************************************************************************/
void    CLoad::vLoadToOrder()
{
    char   szDate[9], szNum[5], szFile[512];

    memset(szNum, 0, sizeof(szNum));
    memset(szFile, 0, sizeof(szFile));
    memset(szDate, 0, sizeof(szDate));
    IBPgetstring("BAT_NUM", szNum, "批次编号");
    IBPgetstring("BAT_DATE", szDate, "清算日期");
    if(IBPIserr())
        return ;

    snprintf(szFile, sizeof(szFile), "%s/pool/VDATA%s_%s.txt", getenv("FILEDIR"), szDate, szNum);
    IBPrace("开始导入交易流水(%s)批次(%s)文件:%s", szDate, szNum, szFile);

    if(RC_SUCC != lDbsConnect(DBS_BATCH))
    {
        SYSError(RET_DATABASE, "连接代扣系统数据库失败, err:(%d)(%s)", SQLCODE, sDbsError())
        return ;
    }

	if(RC_SUCC != lLoadFromFile(szFile, szDate, szNum))
	{
        EXEC SQL ROLLBACK WORK;
    	vDbsDisconnect();
		return ;
	}

    vDbsDisconnect();

    return ;
}

/*************************************************************************************************
    code end
**************************************************************************************************/
