/****************************************************************************************
    文 件 名  : CheckComfun.c
    作      者  : DeffPuzzL
    版      本  : V2.0.0.0
    创建日期  : 2016-01-10
    描      述  : 渠道流水特殊定义
 ****************************************************************************************/
#include "face.h"
#include "cups.h"
#include "dbsapi.h"
#include "load_cups.h"
#define  SQLCA_STORAGE_CLASS     extern
#include "sqlca.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "tbl_cups_succ.h"
EXEC SQL END DECLARE SECTION;

/****************************************************************************************
    设置字段域表结构映射
 ****************************************************************************************/
long    CCups::lMapCupsValue(TCupsSucc *pstCups, char *pszName, char *pszValue)
{
    if(!strcmp(pszName, "id"))
        memcpy(pstCups->id, pszValue, sizeof(pstCups->id) - 1);    
    else if(!strcmp(pszName, "stlm_date"))
        memcpy(pstCups->stlm_date, pszValue, sizeof(pstCups->stlm_date) - 1);    
    else if(!strcmp(pszName, "tx_date"))
        memcpy(pstCups->tx_date, pszValue, sizeof(pstCups->tx_date) - 1);    
    else if(!strcmp(pszName, "tx_time"))
        memcpy(pstCups->tx_time, pszValue, sizeof(pstCups->tx_time) - 1);    
    else if(!strcmp(pszName, "trace_no"))
        memcpy(pstCups->trace_no, pszValue, sizeof(pstCups->trace_no) - 1);    
    else if(!strcmp(pszName, "cup_key"))
        memcpy(pstCups->cup_key, pszValue, sizeof(pstCups->cup_key) - 1);    
    else if(!strcmp(pszName, "result_flag"))
        memcpy(pstCups->result_flag, pszValue, sizeof(pstCups->result_flag) - 1);    
    else if(!strcmp(pszName, "channel_no"))
        memcpy(pstCups->channel_no, pszValue, sizeof(pstCups->channel_no) - 1);    
    else if(!strcmp(pszName, "term_no"))
        memcpy(pstCups->term_no, pszValue, sizeof(pstCups->term_no) - 1);    
    else if(!strcmp(pszName, "ac_no"))
    {
        sTrimAll(pszValue);
        memcpy(pstCups->ac_no, pszValue, sizeof(pstCups->ac_no) - 1);    
    }
    else if(!strcmp(pszName, "user_name"))
    {
        sTrimAll(pszValue);
        memcpy(pstCups->user_name, pszValue, sizeof(pstCups->user_name) - 1);    
    }
    else if(!strcmp(pszName, "ac_bank_no"))
        memcpy(pstCups->ac_bank_no, pszValue, sizeof(pstCups->ac_bank_no) - 1);    
    else if(!strcmp(pszName, "tx_amt"))
    {
        sTrimAll(pszValue);
        pstCups->tx_amt = atof(pszValue);
    }
    else if(!strcmp(pszName, "cup_fee"))
    {
        sTrimAll(pszValue);
        pstCups->cup_fee = atof(pszValue);
    }
    else if(!strcmp(pszName, "tx_code"))
        memcpy(pstCups->tx_code, pszValue, sizeof(pstCups->tx_code) - 1);    
    else if(!strcmp(pszName, "sys_ref_no"))
    {
        sTrimAll(pszValue);
        memcpy(pstCups->sys_ref_no, pszValue, sizeof(pstCups->sys_ref_no) - 1);    
    }
    else if(!strcmp(pszName, "brf"))
        memcpy(pstCups->brf, pszValue, sizeof(pstCups->brf) - 1);    
    else if(!strcmp(pszName, "fill"))
    {
        sTrimAll(pszValue);
        memcpy(pstCups->fill, pszValue, sizeof(pstCups->fill) - 1);    
    }
    else if(!strcmp(pszName, "res"))
        memcpy(pstCups->res, pszValue, sizeof(pstCups->res) - 1);    
    else if(!strcmp(pszName, "channel_nm"))
        strncpy(pstCups->channel_nm, pszValue, sizeof(pstCups->channel_nm) - 1);    
    else if(!strcmp(pszName, "ac_bank_name"))
        strncpy(pstCups->bank_branch_name, pszValue, sizeof(pstCups->bank_branch_name) - 1);    

    return RC_SUCC;
}

/****************************************************************************************
    通过sysref 对渠道流水的撤销
 ****************************************************************************************/
long    CCups::lAbolishCupsTxn(Benum eMode, ReList *pstReList)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char    szSysRef[50], stStlmDate[9];
    char    szCupsNo[5], szFlag[2];
    EXEC SQL END DECLARE SECTION;
    ReList        stReList, *pstList = NULL;
    long        lCount = 0;

    memset(szFlag, 0, sizeof(szFlag));
    memset(szCupsNo, 0, sizeof(szCupsNo));
    memset(szSysRef, 0, sizeof(szSysRef));
    memset(stStlmDate, 0, sizeof(stStlmDate));

    szFlag[0] = CUP_SUCC_REVERSED;
    strncpy(szCupsNo, sGetLoadCups(), sizeof(szCupsNo) - 1);
    pstList = pstReList;
    while(pstList)
    {
        memset(szSysRef, 0, sizeof(szSysRef));
        memset(stStlmDate, 0, sizeof(stStlmDate));
        strncpy(szSysRef, pstList->m_szSysRefNo, sizeof(szSysRef));
        strncpy(stStlmDate, pstList->m_szTxDate, sizeof(stStlmDate));

        IBPrace("序号(%d), 撤销/冲正流水(%s)(%s)", ++ lCount, stStlmDate, szSysRef);

        if(REVOCATE_SYSREF == eMode)
        {
            EXEC SQL UPDATE TBL_CUP_SUCC SET
                RESULT_FLAG = :szFlag
            WHERE SYS_REF_NO = :szSysRef AND STLM_DATE = :stStlmDate 
                AND CUPS_NO = :szCupsNo;
        }
        else if(REVOCATE_TRACE == eMode)
        {
            EXEC SQL UPDATE TBL_CUP_SUCC SET
                RESULT_FLAG = :szFlag
            WHERE TRACE_NO = :szSysRef AND STLM_DATE = :stStlmDate 
                AND CUPS_NO = :szCupsNo;
        }
        else if(REVOCATE_CUPKEY == eMode)
        {
            EXEC SQL UPDATE TBL_CUP_SUCC SET
                RESULT_FLAG = :szFlag
            WHERE CUP_KEY = :szSysRef AND STLM_DATE = :stStlmDate 
                AND CUPS_NO = :szCupsNo;
        }
        else
        {
            SYSError(RET_DATABASE, "未定义的(%d)更新渠道(%s)流水类型", eMode, szCupsNo);
            EXEC SQL ROLLBACK WORK;
            return RC_FAIL;
        }
        if(SQLCODE)
        {
            SYSError(RET_DATABASE, "更新渠道(%s)流水失败, err:(%d)(%s)", szCupsNo,
                SQLCODE, sDbsError());
            EXEC SQL ROLLBACK WORK;
            return RC_FAIL;
        }

        if(lCount % 100)
            EXEC SQL COMMIT WORK;

        pstList = pstList->pstNext;
    }
    EXEC SQL COMMIT WORK;

    IBPrace("对渠道(%s)撤销流水记录(%d)处理完毕", sGetLoadCups(), lCount);

    return RC_SUCC;
}

/****************************************************************************************
    通过sysref 对渠道流水的撤销
 ****************************************************************************************/
long    CCups::lAlpyAbolishCupsTxn(ReList *pstReList)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char    szSysRef[50], stStlmDate[9];
    char    sId[23], szCupsNo[5], szFlag[2];
    EXEC SQL END DECLARE SECTION;
    ReList        stReList, *pstList = NULL;
    long        lCount = 0;

    memset(szFlag, 0, sizeof(szFlag));
    memset(sId, 0, sizeof(sId));
    memset(szCupsNo, 0, sizeof(szCupsNo));
    memset(szSysRef, 0, sizeof(szSysRef));
    memset(stStlmDate, 0, sizeof(stStlmDate));

    szFlag[0] = CUP_SUCC_REVERSED;
    strncpy(szCupsNo, sGetLoadCups(), sizeof(szCupsNo) - 1);
    pstList = pstReList;
    while(pstList)
    {
        memset(sId, 0, sizeof(sId));
        memset(szSysRef, 0, sizeof(szSysRef));
        memset(stStlmDate, 0, sizeof(stStlmDate));
        strncpy(szSysRef, pstList->m_szSysRefNo, sizeof(szSysRef));
        strncpy(stStlmDate, pstList->m_szTxDate, sizeof(stStlmDate));

        IBPrace("序号(%d), 撤销/冲正流水(%s)(%s)", ++ lCount, stStlmDate, szSysRef);

        EXEC SQL UPDATE TBL_CUP_SUCC SET
            RESULT_FLAG = :szFlag
        WHERE CUP_KEY = :szSysRef AND STLM_DATE = :stStlmDate 
            AND CUPS_NO = :szCupsNo;
        if(SQLCODE)
        {
            SYSError(RET_DATABASE, "更新渠道(%s)流水失败, err:(%d)(%s)", szCupsNo,
                SQLCODE, sDbsError());
            EXEC SQL ROLLBACK WORK;
            return RC_FAIL;
        }

        EXEC SQL SELECT ID INTO :sId FROM TBL_TXN_SUCC WHERE CUP_KEY = :szSysRef;
        if(SQLERR)
        {
            SYSError(RET_DATABASE, "查询本地(%s)流水失败, err:(%d)(%s)", szSysRef,
                SQLCODE, sDbsError());
            EXEC SQL ROLLBACK WORK;
            return RC_FAIL;
        }

        sTrimAll(sId);

        if(SQLOK)
        {
            EXEC SQL UPDATE TBL_TXN_SUCC SET RESULT_FLAG = '9' WHERE ID = :sId;
            if(SQL_UD_ERR || 1 != EFFECT_NUM)
            {
                SYSError(RET_DATABASE, "更新本地(%s)TBL_TXN_SUCC流水失败, err:(%d)(%s)", sId,
                    SQLCODE, sDbsError());
                EXEC SQL ROLLBACK WORK;
                return RC_FAIL;
            }

            EXEC SQL DELETE FROM TBL_STLM_SUCC WHERE ID = :sId;
            if(SQL_UD_ERR)
            {
                SYSError(RET_DATABASE, "删除本地(%s)TBL_STLM_SUCC流水失败, err:(%d)(%s)", sId,
                    SQLCODE, sDbsError());
                EXEC SQL ROLLBACK WORK;
                return RC_FAIL;
            }

            EXEC SQL DELETE FROM TBL_ALGO_DTL WHERE ID = :sId;
            if(SQL_UD_ERR)
            {
                SYSError(RET_DATABASE, "删除本地(%s)TBL_ALGO_DTL流水失败, err:(%d)(%s)", sId,
                    SQLCODE, sDbsError());
                EXEC SQL ROLLBACK WORK;
                return RC_FAIL;
            }

            EXEC SQL DELETE FROM TBL_ALGO_DTL_ASSIST WHERE ID = :sId;
            if(SQL_UD_ERR)
            {
                SYSError(RET_DATABASE, "删除本地(%s)TBL_ALGO_DTL_ASSIST流水失败, err:(%d)(%s)", sId,
                    SQLCODE, sDbsError());
                EXEC SQL ROLLBACK WORK;
                return RC_FAIL;
            }

            EXEC SQL DELETE FROM TBL_FEE_INF WHERE ID = :sId;
            if(SQL_UD_ERR)
            {
                SYSError(RET_DATABASE, "删除本地(%s)TBL_FEE_INF流水失败, err:(%d)(%s)", sId,
                    SQLCODE, sDbsError());
                EXEC SQL ROLLBACK WORK;
                return RC_FAIL;
            }
        }

        if(lCount % 100)
            EXEC SQL COMMIT WORK;

        pstList = pstList->pstNext;
    }
    EXEC SQL COMMIT WORK;

    IBPrace("对渠道(%s)撤销流水记录(%d)处理完毕", sGetLoadCups(), lCount);

    return RC_SUCC;
}

/****************************************************************************************
    cpnr特殊撤销处理方法
 ****************************************************************************************/
long    CCups::lCpnr_AbolishTrade(void *pstVoid, void *pstCom)
{
    long    lCount = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    char    szTxDate[9], szTraceNo[13], szFlag[2], szStlmDate[9];
    char    szCupsNo[5], szFd11[7], szFd13[5], szYear[5];
    char    szTrace[7],  szMonDay[5];
    EXEC SQL END DECLARE SECTION;

    memset(szFlag, 0, sizeof(szFlag));
    memset(szCupsNo, 0, sizeof(szCupsNo));
    memset(szStlmDate, 0, sizeof(szStlmDate));

    szFlag[0] = CUP_SUCC_REVERSED;
    strcpy(szCupsNo, sGetLoadCups());
    memcpy(szStlmDate, sGetLoadDate(), sizeof(szStlmDate) - 1);

    EXEC SQL DECLARE Cur_cup_succ CURSOR FOR 
        SELECT NVL(TX_DATE, ' '), NVL(TRACE_NO, ' ') 
            FROM TBL_CUP_SUCC WHERE
        STLM_DATE = :szStlmDate AND CUPS_NO = :szCupsNo AND RESULT_FLAG = :szFlag;

    EXEC SQL OPEN Cur_cup_succ;
    if(SQLCODE)
    {
        SYSError(RET_DATABASE, "打开渠道流水表失败, err:(%d)(%s)", SQLCODE, sDbsError());
        return RC_FAIL;
    }

    while(1)
    {
        memset(szTxDate, 0, sizeof(szTxDate));
        memset(szTraceNo, 0, sizeof(szTraceNo));
        EXEC SQL FETCH Cur_cup_succ INTO :szTxDate, :szTraceNo;
        if(SQLERR)
        {
            SYSError(RET_DATABASE, "获取渠道流水表失败, err:(%d)(%s)", SQLCODE, sDbsError());
            EXEC SQL CLOSE Cur_cup_succ;
            EXEC SQL ROLLBACK WORK;
            return RC_FAIL;
        }
        else if(SQLNOTFOUND)
            break;

        sTrimAll(szTraceNo);
        sTrimAll(szTxDate);

        memset(szYear, 0, sizeof(szYear));
        memcpy(szYear, szTxDate, 4);

        memset(szFd11, 0, sizeof(szFd11));
        memset(szFd13, 0, sizeof(szFd13));
        memcpy(szFd13, szTxDate + 4, sizeof(szFd13) - 1);
        memcpy(szFd11, szTraceNo + 6, sizeof(szFd11) - 1);

        //    // 渠道明确撤销掉的交易
        memset(szTrace, 0, sizeof(szTrace));
        memset(szMonDay, 0, sizeof(szMonDay));
        IBPrace("日期[%s]对撤销流水[%s]", szTxDate, szTraceNo);

        EXEC SQL SELECT NVL(FD11, ' '), NVL(FD13, ' ') INTO :szTrace, :szMonDay
            FROM TBL_TXN_SUCC WHERE ORDER_NO = (
                SELECT NVL(ORDER_NO, ' ') FROM TBL_TXN_SUCC WHERE CUPS_NO = :szCupsNo
                    AND FD13 = :szFd13 AND FD11 = :szFd11 AND SUBSTR(TX_DATE,1,4) = :szYear)
            AND TX_SUB_CODE IN ('31','51');
        if(SQLCODE)
        {
            SYSError(RET_DATABASE, "tbl_txn_succ err:(%d)(%s), date(%s)fd11(%s)", SQLCODE, 
                sDbsError(), szTxDate, szTraceNo + 6);
            EXEC SQL CLOSE Cur_cup_succ;
            lDbsRollback();
            return RC_FAIL;
        }

        sTrimAll(szTrace);
        sTrimAll(szMonDay);

        EXEC SQL UPDATE TBL_CUP_SUCC SET
            RESULT_FLAG = :szFlag
        WHERE SUBSTR(TRACE_NO,7,6) = :szTrace AND SUBSTR(TX_DATE,5,4) = :szMonDay
            AND SUBSTR(TX_DATE,1,4) = :szYear AND CUPS_NO = :szCupsNo;
        if(SQLCODE)
        {
           SYSError(RET_DATABASE, "更新渠道(%s)流水失败, err:(%d)(%s), (%s)(%s)(%s)(%s)", szCupsNo,
                SQLCODE, sDbsError(), szTrace, szMonDay, szTraceNo, szYear);
            EXEC SQL CLOSE Cur_cup_succ;
            EXEC SQL ROLLBACK WORK;
            return RC_FAIL;
        }

        if( ++ lCount % 100)
            EXEC SQL COMMIT WORK;
    }
    EXEC SQL COMMIT WORK;

    IBPrace("对渠道(%s)撤销流水记录(%d)处理完毕", sGetLoadCups(), lCount);

    return RC_SUCC;
}

/****************************************************************************************
    修复年份
 ****************************************************************************************/
long    lFixCpnrYear(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen)
{
    char    szDate[20], szMonth[5], szYear[5];
    long    lYear = 0;

    memset(szDate, 0, sizeof(szDate));
    memset(szYear, 0, sizeof(szYear));
    memset(szMonth, 0, sizeof(szMonth));
    strncpy(szYear, pszValue, 4);
    strncpy(szDate, pszValue + 4, 4);
    strncpy(szMonth, pszValue + 8, 4);

    if(0 == memcmp(szDate, "0101", 4) && 0 == memcmp(szMonth, "1231", 4))
        lYear = atol(szYear) + 1;
      else
        lYear = atol(szYear);
    snprintf(pszValue, *plValueLen,  "%4d%s", lYear, szDate);

    return RC_SUCC;
}

/****************************************************************************************
    对时间 HH:MM:ss处理成 HHMMSS
 ****************************************************************************************/
long    lFixTxTime(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen)
{
    char    szTime[20];

    memset(szTime, 0, sizeof(szTime));
    strncpy(szTime, pszValue, sizeof(szTime));

    memset(pszValue, 0, *plValueLen);
    memcpy(pszValue, szTime, 2);
    memcpy(pszValue + 2, szTime + 3, 2);
    memcpy(pszValue + 4, szTime + 6, 2);

    return RC_SUCC;
}

/****************************************************************************************
    对时间 YYYY/MM/DD处理成 YYYYMMDD格式
 ****************************************************************************************/
long    lFixTxDate(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen)
{
    char    szDate[20];
    memset(szDate, 0, sizeof(szDate));
    strncpy(szDate, pszValue, sizeof(szDate));

    memset(pszValue, 0, *plValueLen);
    memcpy(pszValue, szDate, 4);
    memcpy(pszValue + 4, szDate + 5, 2);
    memcpy(pszValue + 6, szDate + 8, 2);

    return RC_SUCC;
}

/****************************************************************************************
    金额分转换元
 ****************************************************************************************/
long    lCentToYuan(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen)
{
    char    szTemp[20];

    sTrimAll(pszValue);
    memset(szTemp, 0, sizeof(szTemp));
    strcpy(szTemp, pszValue);

    sprintf(pszValue, "%.2f", atof(szTemp) / 100.00);

    return RC_SUCC;
}

/****************************************************************************************
    double类型取负
 ****************************************************************************************/
long    lMinusDouble(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen)
{
    double    dAmt = 0.00;


    dAmt = atof(pszValue);
    dAmt = -1 * dAmt;

    memset(pszValue, 0, *plValueLen);
    snprintf(pszValue, *plValueLen, "%.2f", dAmt);

    return RC_SUCC;
}

/****************************************************************************************
    long类型取负
 ****************************************************************************************/
long    lMinusLong(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen)
{
    long    lNumb = 0;

    lNumb = atol(pszValue);
    lNumb = -1 * lNumb;

    memset(pszValue, 0, *plValueLen);
    snprintf(pszValue, *plValueLen, "%d", lNumb);

    return RC_SUCC;
}

/****************************************************************************************
    装载渠道流水规则，第一列非数字
 ****************************************************************************************/
long    lIsNumbBegin(char *pszCupsNo, char *pszDate, char *pszValue, long *plSize)
{
    if(strlen(pszValue) == 0 || pszValue[0] > '9' || pszValue[0] < '0')
        return RC_FAIL;
    else 
        return RC_SUCC;
}

/****************************************************************************************
    去掉字符串中的空格
 ****************************************************************************************/
long    lTrimAll(char *pszCupsNo, char *pszDate, char *pszValue, long *plSize)
{
    sTrimAll(pszValue);
    return RC_SUCC;
}

/****************************************************************************************
    去掉字符串尾部空格和tab
 ****************************************************************************************/
long    lTrimRight(char *pszCupsNo, char *pszDate, char *pszValue, long *plSize)
{
    sTrimRight(pszValue);
    return RC_SUCC;
}

/****************************************************************************************
    去掉字符串前部空格和tab    
 ****************************************************************************************/
long    lTrimLeft(char *pszCupsNo, char *pszDate, char *pszValue, long *plSize)
{
    sTrimLeft(pszValue);
    return RC_SUCC;
}

/****************************************************************************************
    装载渠道流水规则，无真实有效数据
 ****************************************************************************************/
long    lIsVaildData(char *pszCupsNo, char *pszDate, char *pszValue, long *plSize)
{
    sTrimAll(pszValue);
    if(0 == strlen(pszValue))    return RC_FAIL;
    else                        return RC_SUCC;
}

/****************************************************************************************
    code end
 ****************************************************************************************/
