/****************************************************************************************
    文 件 名  : LoadChnCom.c
    作      者  : DeffPuzzL
    版      本  : V2.0.0.0
    创建日期  : 2016-01-10
    描      述  : 渠道流水装载框架
 ****************************************************************************************/
#include "face.h"
#include "cups.h"
#include "load_cups.h"
#define   SQLCA_STORAGE_CLASS     extern
#include  "sqlca.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "tbl_cups_succ.h"
EXEC SQL END DECLARE SECTION;

extern long lFixTxDate(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lFixTxTime(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lFixCpnrYear(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lCentToYuan(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lIsNumbBegin(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lMinusDouble(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lMinusLong(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lIsVaildData(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lTrimAll(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lTrimRight(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lTrimLeft(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lFixTxDate(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lFixTxDate(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);
extern long lFixTxDate(char *pszCupsNo, char *pszDate, char *pszValue, long *plValueLen);

/****************************************************************************************
    全局定义区
 ****************************************************************************************/
CMList        *g_pstConfig = NULL;
LoadRun        g_stLoad;

/****************************************************************************************
    函数定义
 ****************************************************************************************/
typedef long    (*Task)(char *, char *, char *, long *pl);
typedef long    (*Check)(void *, void *);


/**************************************************************************************************
    方法定义
 **************************************************************************************************/
CCups::stEvent CCups::m_stEvent[] =
{
    {"cups",            &CCups::vLoadChnCom },
    { "", NULL }
};

/**************************************************************************************************
    函 数 名：CCups()
    功能描述：构造函数
    返回说明：
 **************************************************************************************************/
CCups::CCups()
{

}

/**************************************************************************************************
    函 数 名：~CCups()
    功能描述：析构函数
    返回说明：
 **************************************************************************************************/
CCups::~CCups()
{


}

/**************************************************************************************************
    函 数 名：lRunObject(char* in_szClass, char* in_szAction)
    功能描述：运行类中的方法
    返回说明：
        RC_SUCC         --成功
        RC_FAIL         --失败
 **************************************************************************************************/
long    CCups::lRunObject(char *in_szClass, char *in_szAction)
{
    int     i = 0;
    char    *p, szAction[256];

    memset(szAction, 0, sizeof(szAction));

    if ((p = strstr(in_szAction, "__")) != NULL)
    {
        strncpy(szAction, in_szAction, p - in_szAction);
    }
    else
    {
        strcpy(szAction, in_szAction);
    }

    while (0 != strcmp(m_stEvent[i].m_szName, ""))
    {
        if (0 == strcmp(m_stEvent[i].m_szName, szAction))
        {
            (this->*m_stEvent[i].m_pEvent)();
            return RC_SUCC;
        }

        i++;
    }

    SYSError(RET_SYSTEM, "组件(%s)的事件(%s)没注册", in_szClass, in_szAction);
    return RC_FAIL;
}

/****************************************************************************************
    清理撤销流水信息信息
 ****************************************************************************************/
CMList*    CCups::pGetCfgList()
{
    return g_pstConfig;
}

/****************************************************************************************
    获取运行时渠道编号 
 ****************************************************************************************/
char*     CCups::sGetLoadCups()
{
    return g_stLoad.szCupsNo;
}

/****************************************************************************************
    设置装载渠道编号
 ****************************************************************************************/
void    CCups::vSetLoadCups(char *p)
{
    if(!p)    return ;
    memcpy(g_stLoad.szCupsNo, p, sizeof(g_stLoad.szCupsNo) - 1);
}

/****************************************************************************************
 *     获取运行时渠道编号 
 *****************************************************************************************/
char*     CCups::sGetLoadFileName()
{
    return g_stLoad.szFileName;
}

/****************************************************************************************
 *     设置装载渠道编号
 *****************************************************************************************/
void    CCups::vSetLoadFileName(char *p)
{
    if(!p)    return ;
    memcpy(g_stLoad.szFileName, p, sizeof(g_stLoad.szFileName) - 1);
}

/****************************************************************************************
    获取运行时装载日期
 ****************************************************************************************/
char*    CCups::sGetLoadDate()
{
    return g_stLoad.szDate;
}

/****************************************************************************************
    后去装载内容
 ****************************************************************************************/
char*    CCups::sGetLoadContent()
{
    return g_stLoad.szLine;
}
/****************************************************************************************
    设置运行时装载日期
 ****************************************************************************************/
void    CCups::vSetLoadDate(char *p)
{
    if(!p)    return ;
    memcpy(g_stLoad.szDate, p, sizeof(g_stLoad.szDate) - 1);
}

/****************************************************************************************
     获取装载行数
 ****************************************************************************************/
long    CCups::lGetLoadLine()
{
    return g_stLoad.lLine;
}

/****************************************************************************************
    获取有效装载记录数
 ****************************************************************************************/
long    CCups::lGetLoadValid()
{
    return g_stLoad.lVaild;
}

/****************************************************************************************
    设置装载行数
 ****************************************************************************************/
void    CCups::vSetLoadLine(long lLine)
{
    g_stLoad.lLine = lLine > 0 ? lLine : 1;
}

/****************************************************************************************
      是否装载 
 ****************************************************************************************/
BOOL    CCups::bIsIgnore()
{
    return g_stLoad.bIgnore;
}

/****************************************************************************************
    设置是否装载
 ****************************************************************************************/
void    CCups::vSetIgnore(BOOL bf)
{
    g_stLoad.bIgnore = (bf == 0 ? false : true);
}

/****************************************************************************************
      是否为冲正流水    
 ****************************************************************************************/
BOOL    CCups::bIsRevocate()
{
    return g_stLoad.bRevocate;
}

/****************************************************************************************
      设置是否为冲正流水    
 ****************************************************************************************/
void    CCups::vSetRevocate(BOOL bf)
{
    g_stLoad.bRevocate = (bf == 0 ? false : true);
}

/****************************************************************************************
    获取字符串s在o和d区间的值
 ****************************************************************************************/
char*    CCups::sGetTruckValue(char *s, char *o, char *d)
{
    static    char    szOut[512];    
    char     *p = NULL, *q = NULL;
    BOOL    flag = false;
    long    l = 0;

    memset(szOut, 0, sizeof(szOut));
    if(!s || !o || !d)    return s;

    l = strlen(o);
    if((p = strstr(s, o)))        flag = true;    
    else                        return s;

    
    for(flag = false, q = s + strlen(s) - 1; q != p; q --)
    {
        if(!strncmp(q, d, strlen(d)))
        {
            flag = true;
            break;
        }
    }
    if(!flag)    return s;
    
    memcpy(szOut, p + l, (long)(q - p - l));
    return szOut;
}

/****************************************************************************************
    设置字段类型
 ****************************************************************************************/
long    CCups::lSetValueType(char *pszValue, long *plType)
{
    if(!strcmp("FIELD_LONG", pszValue))
        *plType = FIELD_LONG;
    else if(!strcmp("FIELD_CHAR", pszValue))
        *plType = FIELD_CHAR;
    else if(!strcmp("FIELD_DOUBLE", pszValue))
        *plType = FIELD_DOUBLE;
    else
    {
        IBPerror("字段类型(%s)设置错误", pszValue);
        return RC_FAIL;
    }

    return RC_SUCC;
}

/****************************************************************************************
    获取字段类型描述
 ****************************************************************************************/
char*    CCups::sGetValueType(long lType)
{
    static    char    szType[20];

    memset(szType, 0, sizeof(szType));
    if(FIELD_LONG == lType)
        strcpy(szType, "FIELD_LONG");
    else if(FIELD_CHAR == lType)
        strcpy(szType, "FIELD_CHAR");
    else if(FIELD_DOUBLE == lType)
        strcpy(szType, "FIELD_DOUBLE");
    else
        ;

    return szType;
}

/****************************************************************************************
    判断字符串s是否是数字
 ****************************************************************************************/
BOOL    CCups::bIsDigit(char *s)
{
    long    i = 0, l;

    if(!s)    return false;
    l = strlen(s);
    if(0 == l)    return false;
    
    for(i = 0; i < l; i ++)
    {
        if(!isdigit(s[i]))
            return false;
    }

    return true;
}

/****************************************************************************************
    转义设置的常量字符串
 ****************************************************************************************/
char*   CCups::sTransCharset(char *s)
{
    char    *p = s, t[3];
    long    i = 0, j = 0, k = 0;

    if(!s)  return s;
    k = strlen(s);
    if(0 == k)  return s;

    for(i = 0, j = 0; i < k; i ++)
    {
        if('\\' == s[i])
        {
            if('t' == s[i + 1])
            {
                p[j ++ ] = '\t';
                i += 1;
                continue;
            }
            else
            {
                strncpy(t, s + 1, 2);
                t[2] = 0x00;
                if(bIsDigit(t))
                {
                    p[j ++] = strtol(t, NULL, 16);
                    i += 2;
                    continue;
                }
            }
        }
        p[j ++] = s[i];
    }
    p[j] = 0x00;

    return s;
}

/****************************************************************************************
    查找字段对应的ID
 ****************************************************************************************/
long    CCups::lGetFiledNameIdx(FiledDef *pstFiled, char *pszName)
{
    FiledDef    *pstCur = pstFiled;

    while(pstCur)
    {
        if(!strcmp(pstCur->szFieldName, pszName))
            return pstCur->lId;

        pstCur = pstCur->pstNext;
    }

    return RC_FAIL;
}

/****************************************************************************************
    新增字段结构链表
 ****************************************************************************************/
FiledDef* CCups::pInsertFiled(FiledDef *pstRoot, FiledDef *pstData, long lSize)
{
    FiledDef  *pstNode = NULL;
    static  FiledDef  *pstCurt = NULL;

    pstNode = (FiledDef *)malloc(sizeof(FiledDef));
    if(!pstNode)
    {
        IBPerror("系统分配内存大小(%d)失败", lSize);
        return pstRoot;
    }

    memcpy(pstNode, pstData, lSize);

    if(!pstRoot)
        pstRoot = pstNode;
    else
    {
        pstNode->pstLast = pstCurt;
        pstCurt->pstNext = pstNode;
    }

    pstCurt = pstNode;
    return pstRoot;
}

/****************************************************************************************
    新增撤销流水结构信息
 ****************************************************************************************/
ReList*    CCups::pInsertReList(ReList *pstRoot, ReList *pstData, long lSize)
{
    ReList  *pstNode = NULL;
    static  ReList  *pstCurt = NULL;

    pstNode = (ReList *)malloc(sizeof(ReList));
    if(!pstNode)
    {
        IBPerror("系统分配内存大小(%d)失败", lSize);
        return pstRoot;
    }

    memcpy(pstNode, pstData, lSize);

    if(!pstRoot)
        pstRoot = pstNode;
    else
    {
        pstNode->pstLast = pstCurt;
        pstCurt->pstNext = pstNode;
    }

    pstCurt = pstNode;
    return pstRoot;
}

/****************************************************************************************
    清理字段配置信息
 ****************************************************************************************/
void    CCups::vDeleteFiled(FiledDef *pstFiled)
{
    FiledDef    *pstVoid = pstFiled, *pstSave = NULL;

    while(pstVoid)
    {
        pstSave = pstVoid;
        IBPClearCfg(pstSave->stComb.lNum, pstSave->stComb.plIdx);
        IBPClearCfg(pstSave->stExp.lNum, pstSave->stExp.pstIdx);

//        IBPFree(((FiledDef *)pstSave)->stComb.plIdx);
//        IBPFree(((FiledDef *)pstSave)->stExp.pstIdx);
        IBPFree(pstSave);

        pstVoid = ((FiledDef *)pstVoid)->pstNext;    
    }
    pstFiled = NULL;
}

/****************************************************************************************
    清理撤销流水信息信息
 ****************************************************************************************/
void    CCups::vDeleteReList(Benum eCfg, Revocate *pstRevoct)
{
    void    *pstVoid = NULL, *pstSave = NULL;

    if(!pstRevoct)    return ;

    //    只有完全退出才设置清除该配置
    if(1 == eCfg)
        IBPClearCfg(pstRevoct->lNum, pstRevoct->pstIdx);

    pstVoid = (ReList *)pstRevoct->pstReList;
    while(pstVoid)
    {
        pstSave = pstVoid;
        pstVoid = ((ReList *)pstVoid)->pstNext;    
        IBPFree(pstSave);    
    }

    pstRevoct->pstReList = NULL;
}

/****************************************************************************************
    清理配置信息
 ****************************************************************************************/
void    CCups::vDestroyConfig(CMList **ppstRoot)
{
    CMList      *pstNode = *ppstRoot, *pstList = NULL;
    CupsCfg        *pstCfg;

    while(pstNode)
    {
        pstList = pstNode;
        pstCfg = (CupsCfg *)pstList->m_psvData;

        //    释放Filed
        vDeleteFiled(pstCfg->pstFiled);    
        vDeleteReList(1, &pstCfg->stRevoct);    
        IBPFree(pstNode->m_psvData);    
        IBPFree(pstList);

        pstNode = pstNode->pstNext;    
    }

       *ppstRoot = NULL;    
}

/****************************************************************************************
    获取对应渠道的配置信息
 ****************************************************************************************/
CupsCfg*    CCups::pGetCupsCfg(char *pszCupsNo)
{
    CMList      *pstNode = (CMList *)pGetCfgList();
    CupsCfg        *pstCfg;

    while(pstNode)
    {
        pstCfg = (CupsCfg *)pstNode->m_psvData;
        if(!strcmp(pstCfg->szCupsNo, pszCupsNo))
            return pstCfg;

        pstNode = pstNode->pstNext;    
    }

    SYSError(RET_SYSTEM, "未找到渠道(%s)对应的配置信息", pszCupsNo);
    return NULL;
}

/****************************************************************************************
    转义变量的值
 ****************************************************************************************/
long    CCups::lTransferValue(char *pszCut, char *pszDest, long lSize, CupsCfg *pstCfg)
{
    FiledDef    *pstDef = NULL;

    if(!pszCut || !strlen(pszCut) || !pstCfg)
        return RC_FAIL;

    pstDef = pstCfg->pstFiled;

    if(('$' != pszCut[0] && 0 == strlen(pszCut + 1)) || !pstDef)
        return RC_FAIL;

    while(pstDef)
      {
        if(!strcmp(pstDef->szFieldName, pszCut + 1))
        {
            strncpy(pszDest, pstDef->szFieldValue, lSize);
            return RC_SUCC;
        }
         pstDef = pstDef->pstNext;
    }

    if(!strcmp(pszCut, "$@"))
    {
        strncpy(pszDest, pstCfg->szCupsNo, lSize);
        return RC_SUCC;
    }

    return RC_FAIL;
}

/****************************************************************************************
    根据ID获取数据的值
 ****************************************************************************************/
char*    CCups::sGetFiledValue(FiledDef *pstFiled, long lIdx, long *plType)
{
    static    char    szValue[256];
    FiledDef        *pstDef = pstFiled;

    memset(szValue, 0, sizeof(szValue));
    while(pstDef)
      {
        if(lIdx == pstDef->lId)
        {
            strncpy(szValue, pstDef->szFieldValue, sizeof(szValue));
            if(plType)    *plType = pstDef->lValueType;
            break;
        }
         pstDef = pstDef->pstNext;
    }

    return szValue;
}

/****************************************************************************************
    获取fmt单个格式
 ****************************************************************************************/
char**  CCups::ppGetFmtParam(char *s, long lSize, long *plOut)
{
    static  char    *ppFmt[30];
    long    i = 0, l = strlen(s), n, j;
    BOOL    bflag = false;

    if(lSize <= 0)
    {
        *plOut = 0;
        return NULL;
    }

    n = j = 0;
    IBPMalloc(ppFmt[n], lSize);
    for(i = 0; i < l; i ++)
    {
        if(!bflag)
        {
            ppFmt[n][j ++] = s[i];
            if('%' == s[i])     bflag = true;
            continue;
        }

        if(('0' <= s[i] && '9' >= s[i]) || '-' == s[i] || '+' == s[i] || '.' == s[i])
        {
            ppFmt[n][j ++] = s[i];      //  %
            continue;
        }
        else if('s' != s[i] && 'f' != s[i] && 'd' != s[i])
        {
            IBPerror("无效标识%(%c)(%d)", s[i], i);
            return NULL;
        }

        ppFmt[n][j ++] = s[i];
        if((i + 1) >= l)    break;

        n ++;
        IBPMalloc(ppFmt[n], lSize);
        bflag = false;
        j = 0;
    }
    *plOut = n + 1;

    return ppFmt;
}

/****************************************************************************************
    获取组合字符串的值
 ****************************************************************************************/
char*    CCups::sGetCombValues(FiledDef *pstFiled, ComFiled *pstComb)
{
    long    lNum = 0, lLen = 0, i, j, lType = 0;
    char    **pp = NULL, szTemp[256];
    static    char    szValue[512];

    memset(szValue, 0, sizeof(szValue));
    if(!pstFiled || !pstComb)    return szValue;

    if(!(pp = ppGetFmtParam(pstComb->szFmt, 30, &lNum)))
    {
        IBPerror("获取组合FORMAT格式列表错误, %s", sGetError());
        return szValue;
    }

    for(i = 0, j = 0; i < pstComb->lNum && i < lNum; i ++, j++)
    {
        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, sGetFiledValue(pstFiled, pstComb->plIdx[i], &lType), sizeof(szTemp));    
        if(FIELD_LONG == lType)
            snprintf(szValue + lLen, sizeof(szValue) - lLen, pp[i], atol(szTemp));    
        else if(FIELD_DOUBLE == lType)
            snprintf(szValue + lLen, sizeof(szValue) - lLen, pp[i], atof(szTemp));    
        else
            snprintf(szValue + lLen, sizeof(szValue) - lLen, pp[i], szTemp);    
        lLen = strlen(szValue);
        IBPFree(pp[i]);
    }

    for(i = lNum - pstComb->lNum; i > 0; i --, j ++)
    {
        snprintf(szValue + lLen, sizeof(szValue) - lLen, pp[j]);
        lLen = strlen(szValue);
        IBPFree(pp[j]);
    }

    return szValue;
}

/****************************************************************************************
    获取对应渠道的配置信息
 ****************************************************************************************/
char*    CCups::sGetNameValue(char *pszCupsNo, char *pszFiled)
{
    static    char    szValue[256];
    CupsCfg        *pstCfg;
    FiledDef    *pstFiled = NULL;

    memset(szValue, 0, sizeof(szValue));
    if(!(pstCfg = pGetCupsCfg(pszCupsNo)))
    {
        IBPerror("错误, %s", sGetError());
        return szValue;
    }

    pstFiled = pstCfg->pstFiled;
    while(pstFiled)
    {
        if(!strcmp(pstFiled->szFieldName, pszFiled))
        {
            strncpy(szValue, pstFiled->szFieldValue, sizeof(szValue));
            break;
        }

        pstFiled = pstFiled->pstNext;    
    }

    return szValue;
}

/****************************************************************************************
    调用用户自己定义函数
 ****************************************************************************************/
long    CCups::lCallUserCheck(char *pszFunc, void *pstVoid, void *pstCom)
{
    void    *pvHand = NULL;
    Check    pCheck = NULL;
    char    szLib[1024];
    long    lRet = 0, lOut = 0;
    char    *pError;

    if(!strlen(pszFunc))    return RC_SUCC;

    memset(&szLib, 0, sizeof(szLib));
    snprintf(szLib, sizeof(szLib), "%s/lib/libtask.so", getenv("HOME"));

    pvHand = dlopen(szLib, RTLD_LAZY);
    if(!pvHand)
    {
        IBPerror("打开(%s)错误, %s", szLib, dlerror());
        return RC_FAIL;
    }

    pCheck = (Check)dlsym(pvHand, pszFunc);
    if((pError = dlerror()) != NULL)
    {
        IBPerror("获取(%s)获取函数地址失败, %s", pszFunc, dlerror());
        dlclose(pvHand);
        return RC_FAIL;
    }

    lRet = (*pCheck)(pstVoid, pstCom);
    dlclose(pvHand);
    if(RC_FAIL == lRet)
        return RC_FAIL;    
    else if(RC_IGNORE == lRet)
        vSetIgnore(true);

    return RC_SUCC;
}

/****************************************************************************************
    调用so执行函数
 ****************************************************************************************/
long    CCups::lExecuteFunc(char *pszFunc, char *pszCupsNo, char *pszDate, char *pszValue,
            long *plLen)
{
    void    *pvHand = NULL;
    Task    pTask = NULL;
    char    szLib[1024];
    long    lRet = 0, lOut = 0;
    char    *pError;

    memset(&szLib, 0, sizeof(szLib));
    snprintf(szLib, sizeof(szLib), "%s/lib/libtask.so", getenv("HOME"));
    
    pvHand = dlopen(szLib, RTLD_LAZY);
    if(!pvHand)
    {
        IBPerror("打开(%s)错误, %s", szLib, dlerror());
        return RC_FAIL;
    }
    
    pTask = (Task)dlsym(pvHand, pszFunc);
    if((pError = dlerror()) != NULL)
    {
        IBPerror("获取(%s)获取函数地址失败, %s", pszFunc, dlerror());
        dlclose(pvHand);
        return RC_FAIL;
    }
    
    lRet = (*pTask)(pszCupsNo, pszDate, pszValue, plLen);
    dlclose(pvHand);
    if(RC_FAIL == lRet)
        return RC_FAIL;    
    else if(RC_IGNORE == lRet)
        vSetIgnore(true);

    return RC_SUCC;
}

/****************************************************************************************
    调用用户自己定义函数
 ****************************************************************************************/
long    CCups::lCallUserFunc(char *pszFunc, char *pszCupsNo, char *pszDate, char *pszValue, 
            long *plLen)
{
    void    *pvHand = NULL;
    Task    pTask = NULL;
    char    szLib[1024];
    long    lRet = 0, lOut = 0;
    char    *pError;

    if(!pszFunc || !strlen(pszFunc))    return RC_SUCC;
    if(!strcmp("lFixTxDate", pszFunc))
        lRet = lFixTxDate(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lFixTxTime", pszFunc))
        lRet = lFixTxTime(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lFixCpnrYear", pszFunc))
        lRet = lFixCpnrYear(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lCentToYuan", pszFunc))
        lRet = lCentToYuan(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lIsNumbBegin", pszFunc))
        lRet = lIsNumbBegin(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lMinusDouble", pszFunc))
        lRet = lMinusDouble(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lMinusLong", pszFunc))
        lRet = lMinusLong(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lIsVaildData", pszFunc))
        lRet = lIsVaildData(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lTrimAll", pszFunc))
        lRet = lTrimAll(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lTrimRight", pszFunc))
        lRet = lTrimRight(pszCupsNo, pszDate, pszValue, plLen);
    else if(!strcmp("lTrimLeft", pszFunc))
        lRet = lTrimLeft(pszCupsNo, pszDate, pszValue, plLen);
    else
        lRet = lExecuteFunc(pszFunc, pszCupsNo, pszDate, pszValue, plLen);
    if(lRet != RC_SUCC)
        return RC_FAIL;

    return RC_SUCC;
}

/****************************************************************************************
    文件内容通过方法剔除规则的行
 ****************************************************************************************/
BOOL    CCups::bIsLoadLine(char *pszLoadFunc, char *pszLine)
{
    long    lRet = 0, lSize = 0;

    if(!pszLoadFunc || !strlen(pszLoadFunc))    return TRUE;

    lSize = sizeof(g_stLoad.szLine);
    lRet = lCallUserFunc(pszLoadFunc, sGetLoadCups(), sGetLoadDate(), pszLine, &lSize);
    if(lRet != RC_SUCC)
    {
        IBPrace("不符合(%s)装载规则行(%d)，不装载, 文件数据如下:\n(%s)", pszLoadFunc, 
            lGetLoadLine(), pszLine);
        return FALSE;
    }

    return TRUE;
}

/****************************************************************************************
    路由参数加载
 ****************************************************************************************/
long    CCups::lRouteCheck(Route *pstRoute, char *pszLine)
{
    long    i = 0, l = 0;
    char    szTemp[200], szValue[20], szFiled[200];

//    TYPE:1,FILED:channel_no+fill+term_no
    memset(szTemp, 0, sizeof(szTemp));
    memset(szFiled, 0, sizeof(szFiled));
    memset(szValue, 0, sizeof(szValue));

    strncpy(szTemp, sGetValueByIdx(pszLine, ",", 1), sizeof(szTemp));
    if(strcmp(sGetValueByIdx(szTemp, ":", 1), "TYPE"))
    {
        IBPerror("错误格式, *ROUTECHECK定义未发现TYPE");
        return RC_FAIL;
    }

    strncpy(szValue, sGetValueByIdx(szTemp, ":", 2), sizeof(szValue));
    pstRoute->lType = atol(szValue);

    memset(szTemp, 0, sizeof(szTemp));
    strncpy(szTemp, sGetValueByIdx(pszLine, ",", 2), sizeof(szTemp));
    if(strcmp(sGetValueByIdx(szTemp, ":", 1), "FILED"))
    {
        IBPerror("错误格式, *ROUTECHECK定义未发现FILED");
        return RC_FAIL;
    }

    memset(szFiled, 0, sizeof(szFiled));
    strncpy(szFiled, sGetValueByIdx(szTemp, ":", 2), sizeof(szFiled));
    l = lGetValidNum(szFiled, "+");
    for(i = 1; i <= l; i ++)
     {
        memset(szValue, 0, sizeof(szValue));
        strcpy(szValue, sGetValueByIdx(szFiled, "+", i));
           sTrimAll(szValue);
        sDropCharset(szValue, '\"');
        if(!strlen(szValue))    continue;

        if(1 == i)
            strncpy(pstRoute->szCNo[0], szValue, sizeof(pstRoute->szCNo[0]));
        else if(2 == i)
            strncpy(pstRoute->szFd42[0], szValue, sizeof(pstRoute->szFd42[0]));
        else if(3 == i)
            strncpy(pstRoute->szTerm[0], szValue, sizeof(pstRoute->szTerm[0]));
        else
        {
            IBPerror("错误格式, *ROUTECHECK路由参数定义错误:%s", szValue);
            return RC_FAIL;
        }
    }

    memset(szTemp, 0, sizeof(szTemp));
    strncpy(szTemp, sGetValueByIdx(pszLine, ",", 3), sizeof(szTemp));
/*    if(strcmp(sGetValueByIdx(szTemp, ":", 1), "FEECHECK"))
    {
        IBPerror("错误格式, *ROUTECHECK定义未发现FEECHECK");
        return RC_FAIL;
    }
*/

    strncpy(pstRoute->szFeeCheckFunc, sGetValueByIdx(szTemp, ":", 2), 
        sizeof(pstRoute->szFeeCheckFunc));
    sTrimAll(pstRoute->szFeeCheckFunc);

    return RC_SUCC;
}

/****************************************************************************************
    冲正规则加载
 ****************************************************************************************/
long    CCups::lReserveTxn(CupsCfg *pstCfg, char *pszLine)
{
    long        i = 0, l = 0;
    Revocate    *pstRevc = NULL;
    char        szTemp[200], szValue[20], szFiled[200];

    if(!pstCfg)    return RC_FAIL;
    pstRevc = &pstCfg->stRevoct;

//    LOAD:1, FILED:channel_no+fill+term_no
    memset(szTemp, 0, sizeof(szTemp));
    memset(szFiled, 0, sizeof(szFiled));
    memset(szValue, 0, sizeof(szValue));

    strncpy(szTemp, sGetValueByIdx(pszLine, ",", 1), sizeof(szTemp));
    if(strcmp(sGetValueByIdx(szTemp, ":", 1), "LOAD"))
    {
        IBPerror("错误格式, *REVOCATE定义未发现TYPE");
        return RC_FAIL;
    }
    strncpy(szValue, sGetValueByIdx(szTemp, ":", 2), sizeof(szValue));
    pstRevc->bLoad = atol(szValue);


    memset(szTemp, 0, sizeof(szTemp));
    strncpy(szTemp, sGetValueByIdx(pszLine, ",", 2), sizeof(szTemp));
    if(strcmp(sGetValueByIdx(szTemp, ":", 1), "FILED"))
    {
        IBPerror("错误格式, *REVOCATE定义未发现FILED");
        return RC_FAIL;
    }

    memset(szFiled, 0, sizeof(szFiled));
    strncpy(szFiled, sGetValueByIdx(szTemp, ":", 2), sizeof(szFiled));
    l = lGetValidNum(szFiled, "+");
    pstRevc->lNum = 2;        //    撤销结构体就2个字段， 这里只需2个ID进行映射
    pstRevc->pstIdx = (IdxValue *)malloc(sizeof(IdxValue) * pstRevc->lNum);
    if(!pstRevc->pstIdx)
    {
        IBPerror("分配系统(%d)内存失败", pstRevc->lNum * sizeof(IdxValue));
        return RC_FAIL;
    }

    for(i = 1; i <= pstRevc->lNum || i <= l; i ++)
     {
        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetValueByIdx(szFiled, "+", i), sizeof(szValue));
        IBPIsVariable(szValue, pstRevc->pstIdx);

        pstRevc->pstIdx[i - 1].lVType = NAME_VALUE_TYPE;
        pstRevc->pstIdx[i - 1].lIdx = lGetFiledNameIdx(pstCfg->pstFiled, szValue + 1);
        if(pstRevc->pstIdx[i - 1].lIdx <= 0)
        {
            IBPerror("字段[%s]未定义", szValue + 1);
            IBPFree(pstRevc->pstIdx);
            return RC_FAIL;
        }
    }

    memset(szTemp, 0, sizeof(szTemp));
    strncpy(szTemp, sGetValueByIdx(pszLine, ",", 3), sizeof(szTemp));
    if(strcmp(sGetValueByIdx(szTemp, ":", 1), "REVOCFUN"))
    {
        IBPerror("错误格式, *REVOCATE定义未发现REVOCFUN");
        return RC_FAIL;
    }

    memset(szFiled, 0, sizeof(szFiled));
    strncpy(pstRevc->szRevocFunc, sGetValueByIdx(szTemp, ":", 2), 
        sizeof(pstRevc->szRevocFunc));
    sTrimAll(pstRevc->szRevocFunc);

    return RC_SUCC;
}

/****************************************************************************************
    检查组合字段
 ****************************************************************************************/
long    CCups::lCheckCombina(char *pszComb, ComFiled *pstComb, FiledDef *pstFiled)
{
    long    j = 0, i = 0;
    char    szValue[50];
    
    if(!pstFiled)    return RC_SUCC;

//    channel_no@tx_date@trace_no
    pstComb->lNum = lGetValidNum(pszComb, "+");
    pstComb->plIdx = (long *)malloc(sizeof(long) * pstComb->lNum);
    if(!pstComb->plIdx)
    {
        IBPerror("分配系统(%d)内存失败", pstComb->lNum * sizeof(long));
        return RC_FAIL;
    }

    for(i = 1; i <= pstComb->lNum; i ++)
    {
        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetValueByIdx(pszComb, "+", i), sizeof(szValue));
        if('$' != szValue[0] || 0 == strlen(szValue + 1))
        {
            IBPerror("设置标签[%s]错误", szValue);
            IBPFree(pstComb->plIdx);
            return RC_FAIL;
        }
        
        pstComb->plIdx[i - 1] = lGetFiledNameIdx(pstFiled, szValue + 1);
        if(pstComb->plIdx[i - 1] <= 0)
        {
            IBPerror("字段[%s]未定义", szValue);
            IBPFree(pstComb->plIdx);
            return RC_FAIL;
        }
    }

    return RC_SUCC;
}

/****************************************************************************************
    解析表达式
 ****************************************************************************************/
long    CCups::lCheckExpress(char *pszFiled, CUPExpress *pstExp, FiledDef *pstFiled)
{
    long    j = 0, i = 0;
    char    szValue[50], *p = NULL;
    
    if(!pstFiled || !pstExp || !pszFiled)    return RC_FAIL;

    j = lGetValidNum(pszFiled, "+");
    pstExp->lNum = j;
    pstExp->pstIdx = (IdxValue *)malloc(sizeof(IdxValue) * j);
    if(!pstExp->pstIdx)
    {
        IBPerror("分配系统(%d)内存失败", j * sizeof(long));
        return RC_FAIL;
    }

    for(i = 1; i <= j; i ++)
    {
        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetValueByIdx(pszFiled, "+", i), sizeof(szValue));
        IBPIsVariable(szValue, pstExp->pstIdx);
/*
        if('$' != szValue[0] || 0 == strlen(szValue + 1))
        {
            IBPerror("设置标签值[%s]错误", szValue);
            IBPFree(pstExp->pstIdx);
            return RC_FAIL;
        }
*/

        if(bIsDigit(szValue + 1))    //    文件中取值
        {
            pstExp->pstIdx[i - 1].lVType = FILE_VALUE_TYPE;
            pstExp->pstIdx[i - 1].lIdx = atol(szValue + 1);
        }
        else         //    从表名称中取值
        {
            pstExp->pstIdx[i - 1].lVType = NAME_VALUE_TYPE;
            pstExp->pstIdx[i - 1].lIdx = lGetFiledNameIdx(pstFiled, szValue + 1);
            if(pstExp->pstIdx[i - 1].lIdx <= 0)
            {
                IBPerror("字段%s未定义", szValue);
                IBPFree(pstExp->pstIdx);
                return RC_FAIL;
            }
        }
    }

    return RC_SUCC;
}

/****************************************************************************************
    表达式函数处理
 ****************************************************************************************/
long    CCups::lAnalyseExpress(char *pszExpress, FiledDef *pstFiled, CupsCfg *pstCfg)
{
    long    i = 0;
    char    szTemp[512], szValue[512], *p = NULL;

    memset(szTemp, 0, sizeof(szTemp));
    memset(szValue, 0, sizeof(szValue));
    if(!strncmp(pszExpress, "if", 2))
    {
        pstFiled->stExp.lConst = ECP_CONST_CONDIT;
            
        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetTruckValue(pszExpress, "(", ")"), sizeof(szValue));

        //    $filed_5+$filed_13="消费00"
        if(!(p = strstr(szValue, "=")))
        {
            IBPerror("表达式:[%s]错误 %s", szValue, sGetError());
            return RC_FAIL;
        }

        strncpy(pstFiled->stExp.szResult, sGetValueByIdx(szValue, "=", 2), 
            sizeof(pstFiled->stExp.szResult));
        sDropCharset(pstFiled->stExp.szResult, '\"');

        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, sGetValueByIdx(szValue, "=", 1), sizeof(szTemp));
        if(RC_SUCC != lCheckExpress(szTemp, &pstFiled->stExp, pstCfg->pstFiled))
        {
            IBPerror("表达式:[%s]错误 %s", pszExpress, sGetError());
            return RC_FAIL;
        }

        strncpy(pstFiled->stExp.szIsMatch, sGetValueByIdx(pszExpress, ",", 2), 
            sizeof(pstFiled->stExp.szIsMatch));
        if(!strlen(pstFiled->stExp.szIsMatch))
        {
            IBPerror("表达式%s不正确", pszExpress);
            return RC_FAIL;
        }
        sDropCharset(pstFiled->stExp.szIsMatch, '\"');

        strncpy(pstFiled->stExp.szNotMatch, sGetValueByIdx(pszExpress, ",", 3), 
            sizeof(pstFiled->stExp.szNotMatch));
        sDropCharset(pstFiled->stExp.szNotMatch, '\"');
    }
    else if(!strncmp(pszExpress, "combina", 7) || !strncmp(pszExpress, "length", 6))
    {
        if(!strncmp(pszExpress, "combina", 7))
            pstFiled->stExp.lConst = ECP_CONST_COMBINA;
        else if(!strncmp(pszExpress, "length", 6))
            pstFiled->stExp.lConst = ECP_CONST_LENGTH;

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetTruckValue(pszExpress, "(", ")"), sizeof(szValue));
        if(RC_SUCC != lCheckExpress(szValue, &pstFiled->stExp, pstCfg->pstFiled))
        {
            IBPerror("表达式:[%s]错误 %s", pszExpress, sGetError());
            return RC_FAIL;
        }
    }
    else if(!strncmp(pszExpress, "operate", 7))
    {
        pstFiled->stExp.lConst = ECP_CONST_OPERATE;

        if('+' == pszExpress[7] || '-' == pszExpress[7] || '*' == pszExpress[7] ||
            '/' == pszExpress[7] || '%' == pszExpress[7])
            pstFiled->stExp.szResult[0] = pszExpress[7];
        else
        {
            IBPerror("表达式:[%s]错误", pszExpress);
            return RC_FAIL;
        }

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetTruckValue(pszExpress, "(", ")"), sizeof(szValue));
//        $cup_key, $result_flag

        if(1 != lGetRecordNum(szValue, ",", strlen(szValue)))
        {
            IBPerror("表达式:[%s]错误", pszExpress);
            return RC_FAIL;
        }

        pstFiled->stExp.lNum = 2;
        pstFiled->stExp.pstIdx = (IdxValue *)malloc(sizeof(IdxValue) * pstFiled->stExp.lNum);
        if(!pstFiled->stExp.pstIdx)
        {
            IBPerror("分配系统(%d)内存失败", pstFiled->stExp.lNum * sizeof(long));
            return RC_FAIL;
        }

        for(i = 1; i <= pstFiled->stExp.lNum; i ++)
        {
            memset(szTemp, 0, sizeof(szTemp));
            strncpy(szTemp, sGetValueByIdx(szValue, ",", i), sizeof(szTemp));
            IBPIsVariable(szTemp, pstFiled->stExp.pstIdx);
        
            pstFiled->stExp.pstIdx[i - 1].lVType = NAME_VALUE_TYPE;
            pstFiled->stExp.pstIdx[i - 1].lIdx = lGetFiledNameIdx(pstCfg->pstFiled, szTemp + 1);
            if(pstFiled->stExp.pstIdx[i - 1].lIdx <= 0)
            {
                IBPerror("字段%s未定义", szTemp);
                IBPFree(pstFiled->stExp.pstIdx);
                return RC_FAIL;
            }
        }
    }
    else if(!strncmp(pszExpress, "strcmp", 6))
    {
        pstFiled->stExp.lConst = ECP_CONST_STRCMP;
//        strcmp($__FILE_SEQ, $result_flag), 1, 0
        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetTruckValue(pszExpress, "(", ")"), sizeof(szValue));

        if(1 != lGetRecordNum(szValue, ",", strlen(szValue)))
        {
            IBPerror("表达式:[%s]错误", pszExpress);
            return RC_FAIL;
        }

        pstFiled->stExp.lNum = 2;
        pstFiled->stExp.pstIdx = (IdxValue *)malloc(sizeof(IdxValue) * pstFiled->stExp.lNum);
        if(!pstFiled->stExp.pstIdx)
        {
            IBPerror("分配系统(%d)内存失败", pstFiled->stExp.lNum * sizeof(long));
            return RC_FAIL;
        }

        for(i = 1; i <= pstFiled->stExp.lNum; i ++)
        {
            memset(szTemp, 0, sizeof(szTemp));
            strncpy(szTemp, sGetValueByIdx(szValue, ",", i), sizeof(szTemp));
            IBPIsVariable(szTemp, pstFiled->stExp.pstIdx);
        
            pstFiled->stExp.pstIdx[i - 1].lVType = NAME_VALUE_TYPE;
            pstFiled->stExp.pstIdx[i - 1].lIdx = lGetFiledNameIdx(pstCfg->pstFiled, szTemp + 1);
            if(pstFiled->stExp.pstIdx[i - 1].lIdx <= 0)
            {
                IBPerror("字段%s未定义", szTemp);
                IBPFree(pstFiled->stExp.pstIdx);
                return RC_FAIL;
            }
        }

        if(!(p = strstr(pszExpress, szValue)))
            return RC_FAIL;

        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, pszExpress + (long )((p - pszExpress) + strlen(szValue)) + 1 , sizeof(szTemp));

        strncpy(pstFiled->stExp.szIsMatch, sGetValueByIdx(szTemp, ",", 2), 
            sizeof(pstFiled->stExp.szIsMatch));
        if(!strlen(pstFiled->stExp.szIsMatch))
        {
            IBPerror("表达式%s不正确", pszExpress);
            return RC_FAIL;
        }

        strncpy(pstFiled->stExp.szNotMatch, sGetValueByIdx(szTemp, ",", 3), 
            sizeof(pstFiled->stExp.szNotMatch));

    }
    else if(!strncmp(pszExpress, "decode", 6))
    {
        pstFiled->stExp.lConst = ECP_CONST_DECODE;
//decode($result_flag, "2";"3";"l";"4"), "POS消费";"POS消费撤销";"rewr"

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetTruckValue(pszExpress, "(", ")"), sizeof(szValue));
//        $result_flag, "2";"3";"l";"4"
        if(1 != lGetRecordNum(szValue, ",", strlen(szValue)))
        {
            IBPerror("表达式:[%s]错误", pszExpress);
            return RC_FAIL;
        }

        pstFiled->stExp.lNum = 1;
        pstFiled->stExp.pstIdx = (IdxValue *)malloc(sizeof(IdxValue) * pstFiled->stExp.lNum);
        if(!pstFiled->stExp.pstIdx)
        {
            IBPerror("分配系统(%d)内存失败", pstFiled->stExp.lNum * sizeof(long));
            return RC_FAIL;
        }

        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, sGetValueByIdx(szValue, ",", 1), sizeof(szTemp));
        IBPIsVariable(szTemp, pstFiled->stExp.pstIdx);
    
        pstFiled->stExp.pstIdx[0].lVType = NAME_VALUE_TYPE;
        pstFiled->stExp.pstIdx[0].lIdx = lGetFiledNameIdx(pstCfg->pstFiled, szTemp + 1);
        if(pstFiled->stExp.pstIdx[0].lIdx <= 0)
        {
            IBPerror("字段%s未定义", szTemp);
            IBPFree(pstFiled->stExp.pstIdx);
            return RC_FAIL;
        }

        strncpy(pstFiled->stExp.szResult, sGetValueByIdx(szValue, ",", 2), 
            sizeof(pstFiled->stExp.szResult));
        sDropCharset(pstFiled->stExp.szResult, '\"');

        if(!(p = strstr(pszExpress, szValue)))
            return RC_FAIL;
        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, pszExpress + (long )((p - pszExpress) + strlen(szValue)) + 1 , sizeof(szTemp));
//    "POS消费";"POS消费撤销";"rewr"

        strncpy(pstFiled->stExp.szIsMatch, sGetValueByIdx(szTemp, ",", 2), 
            sizeof(pstFiled->stExp.szIsMatch));
        if(!strlen(pstFiled->stExp.szIsMatch))
        {
            IBPerror("表达式%s不正确", pszExpress);
            return RC_FAIL;
        }
        sDropCharset(pstFiled->stExp.szIsMatch, '\"');

        strncpy(pstFiled->stExp.szNotMatch, sGetValueByIdx(szTemp, ",", 3), 
            sizeof(pstFiled->stExp.szNotMatch));
        sDropCharset(pstFiled->stExp.szNotMatch, '\"');
    }
    else if(!strncmp(pszExpress, "substr", 6))
    {
        pstFiled->stExp.lConst = ECP_CONST_SUBSTR;

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetTruckValue(pszExpress, "(", ")"), sizeof(szValue));
//    $cup_key, 0, 2
        if(2 != lGetRecordNum(szValue, ",", strlen(szValue)))
        {
            IBPerror("表达式:[%s]错误", pszExpress);
            return RC_FAIL;
        }

        pstFiled->stExp.lNum = 1;
        pstFiled->stExp.pstIdx = (IdxValue *)malloc(sizeof(IdxValue) * pstFiled->stExp.lNum);
        if(!pstFiled->stExp.pstIdx)
        {
            IBPerror("分配系统(%d)内存失败", pstFiled->stExp.lNum * sizeof(long));
            return RC_FAIL;
        }

        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, sGetValueByIdx(szValue, ",", 1), sizeof(szTemp));
        IBPIsVariable(szTemp, pstFiled->stExp.pstIdx);
    
        pstFiled->stExp.pstIdx[0].lVType = NAME_VALUE_TYPE;
        pstFiled->stExp.pstIdx[0].lIdx = lGetFiledNameIdx(pstCfg->pstFiled, szTemp + 1);
        if(pstFiled->stExp.pstIdx[0].lIdx <= 0)
        {
            IBPerror("字段%s未定义", szTemp);
            IBPFree(pstFiled->stExp.pstIdx);
            return RC_FAIL;
        }

        strncpy(pstFiled->stExp.szResult, szValue + strlen(szTemp) + strlen(","), 
            sizeof(pstFiled->stExp.szResult));
        sDropCharset(pstFiled->stExp.szResult, '\"');

        pstFiled->lFiledFrom = atol(sGetValueByIdx(pstFiled->stExp.szResult, ",", 1));
        pstFiled->lFiledPos = atol(sGetValueByIdx(pstFiled->stExp.szResult, ",", 2));
        pstFiled->lFiledFrom = pstFiled->lFiledFrom > 0 ? pstFiled->lFiledFrom : 0;
        pstFiled->lFiledPos = pstFiled->lFiledPos > 0 ? pstFiled->lFiledPos : 0;
    }
    else if(!strncmp(pszExpress, "strstr", 6))
    {
        pstFiled->stExp.lConst = ECP_CONST_STRSTR;

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetTruckValue(pszExpress, "(", ")"), sizeof(szValue));

        if(1 != lGetRecordNum(szValue, ",", strlen(szValue)))
        {
            IBPerror("表达式:[%s]错误", pszExpress);
            return RC_FAIL;
        }

        pstFiled->stExp.lNum = 1;
        pstFiled->stExp.pstIdx = (IdxValue *)malloc(sizeof(IdxValue) * pstFiled->stExp.lNum);
        if(!pstFiled->stExp.pstIdx)
        {
            IBPerror("分配系统(%d)内存失败", pstFiled->stExp.lNum * sizeof(long));
            return RC_FAIL;
        }

        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, sGetValueByIdx(szValue, ",", 1), sizeof(szTemp));
        IBPIsVariable(szTemp, pstFiled->stExp.pstIdx);
    
        pstFiled->stExp.pstIdx[0].lVType = NAME_VALUE_TYPE;
        pstFiled->stExp.pstIdx[0].lIdx = lGetFiledNameIdx(pstCfg->pstFiled, szTemp + 1);
        if(pstFiled->stExp.pstIdx[0].lIdx <= 0)
        {
            IBPerror("字段%s未定义", szTemp);
            IBPFree(pstFiled->stExp.pstIdx);
            return RC_FAIL;
        }

        strncpy(pstFiled->stExp.szResult, sGetValueByIdx(szValue, ",", 2), 
            sizeof(pstFiled->stExp.szResult));
        sDropCharset(pstFiled->stExp.szResult, '\"');

        if(!(p = strstr(pszExpress, szValue)))
            return RC_FAIL;
        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, pszExpress + (long )((p - pszExpress) + strlen(szValue)) + 1 , sizeof(szTemp));

        strncpy(pstFiled->stExp.szIsMatch, sGetValueByIdx(szTemp, ",", 2), 
            sizeof(pstFiled->stExp.szIsMatch));
        if(!strlen(pstFiled->stExp.szIsMatch))
        {
            IBPerror("表达式%s不正确", pszExpress);
            return RC_FAIL;
        }
        sDropCharset(pstFiled->stExp.szIsMatch, '\"');

        strncpy(pstFiled->stExp.szNotMatch, sGetValueByIdx(szTemp, ",", 3), 
            sizeof(pstFiled->stExp.szNotMatch));
        sDropCharset(pstFiled->stExp.szNotMatch, '\"');
    }
    else if(!strncmp(pszExpress, "less", 4))
    {
        pstFiled->stExp.lConst = ECP_CONST_LESS;
//    less($channel_no, $__FILE_SEQ), 1, 0
        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetTruckValue(pszExpress, "(", ")"), sizeof(szValue));

        if(1 != lGetRecordNum(szValue, ",", strlen(szValue)))
        {
            IBPerror("表达式:[%s]错误", pszExpress);
            return RC_FAIL;
        }

        pstFiled->stExp.lNum = 2;
        pstFiled->stExp.pstIdx = (IdxValue *)malloc(sizeof(IdxValue) * pstFiled->stExp.lNum);
        if(!pstFiled->stExp.pstIdx)
        {
            IBPerror("分配系统(%d)内存失败", pstFiled->stExp.lNum * sizeof(long));
            return RC_FAIL;
        }

        for(i = 1; i <= pstFiled->stExp.lNum; i ++)
        {
            memset(szTemp, 0, sizeof(szTemp));
            strncpy(szTemp, sGetValueByIdx(szValue, ",", i), sizeof(szTemp));
            IBPIsVariable(szTemp, pstFiled->stExp.pstIdx);
        
            pstFiled->stExp.pstIdx[i - 1].lVType = NAME_VALUE_TYPE;
            pstFiled->stExp.pstIdx[i - 1].lIdx = lGetFiledNameIdx(pstCfg->pstFiled, szTemp + 1);
            if(pstFiled->stExp.pstIdx[i - 1].lIdx <= 0)
            {
                IBPerror("字段%s未定义", szTemp);
                IBPFree(pstFiled->stExp.pstIdx);
                return RC_FAIL;
            }
        }

        if(!(p = strstr(pszExpress, szValue)))
            return RC_FAIL;
        memset(szTemp, 0, sizeof(szTemp));
        strncpy(szTemp, pszExpress + (long )((p - pszExpress) + strlen(szValue)) + 1 , sizeof(szTemp));

        strncpy(pstFiled->stExp.szIsMatch, sGetValueByIdx(szTemp, ",", 2), 
            sizeof(pstFiled->stExp.szIsMatch));
        if(!strlen(pstFiled->stExp.szIsMatch))
        {
            IBPerror("表达式%s不正确", pszExpress);
            return RC_FAIL;
        }

        strncpy(pstFiled->stExp.szNotMatch, sGetValueByIdx(szTemp, ",", 3), 
            sizeof(pstFiled->stExp.szNotMatch));
    }
    else 
    {
        pstFiled->stExp.lConst = ECP_CONST_STRING;
        IBPTrimAbout(pszExpress);
        sDropCharset(pszExpress, '\"');
        if('$' == pszExpress[0] && 0 == strlen(pszExpress + 1))
        {
            IBPerror("设置标签值[%s]错误", pszExpress);
            return RC_FAIL;
        }
        
        if(RC_FAIL == lTransferValue(pszExpress, pstFiled->szFieldValue, sizeof(pstFiled->szFieldValue), 
            pstCfg))
        {
            sTransCharset(pszExpress);
            strncpy(pstFiled->szFieldValue, pszExpress, sizeof(pstFiled->szFieldValue));
            strncpy(pstFiled->stExp.szIsMatch, pstFiled->szFieldValue, 
                sizeof(pstFiled->stExp.szIsMatch));
        }
    }

    return RC_SUCC;
}

/****************************************************************************************
    字段规则定义
 ****************************************************************************************/
long    CCups::lFiledDefine(CupsCfg *pstCfg, char *pszLine, long lIdx)
{
    FiledDef    stFiled;
    long    i = 0, l = 0, lRet = 0;
    char    szTemp[512], szValue[512], szFiled[512], *p = NULL;

//    TYPE:1,FILED:channel_no+fill+term_no
    memset(szTemp, 0, sizeof(szTemp));
    memset(szValue, 0, sizeof(szValue));

    memset(&stFiled, 0, sizeof(stFiled));
    strncpy(stFiled.szFieldName, sGetValueByIdx(pszLine, "=", 1), sizeof(stFiled.szFieldName));
    sTrimAll(stFiled.szFieldName);
    stFiled.lId = lIdx;

    memset(szTemp, 0, sizeof(szTemp));
    p = strstr(pszLine, "=");
    if(!p)    return RC_FAIL;
    strncpy(szTemp, p + strlen("="), sizeof(szTemp));

    l = strlen(szTemp);
    if('{' == szTemp[0] && '}' == szTemp[l - 1])
    {
        memset(szFiled, 0, sizeof(szFiled));
        strncpy(szFiled, sGetTruckValue(szTemp, "{", "}"), sizeof(szFiled));
        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetValueByIdx(szFiled, ",", 1), sizeof(szValue));
        if(RC_SUCC != lSetValueType(szValue, &stFiled.lValueType))
        {
            IBPerror("%s, 字段%s%s", pszLine, stFiled.szFieldName, sGetError());
            return RC_FAIL;
        }

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetValueByIdx(szFiled, ",", 2), sizeof(szValue));
        stFiled.lFieldType = atol(szValue);
        if(FILE_FIXD_VALUE == stFiled.lFieldType)
        {
            stFiled.lFiledFrom = atol(sGetValueByIdx(szFiled, ",", 3));
            stFiled.lFiledPos = atol(sGetValueByIdx(szFiled, ",", 4));
        }
        else if(FILE_BLOCK_VALUE == stFiled.lFieldType)    //    分隔符文件
        {
            memset(szTemp, 0, sizeof(szTemp));
            strncpy(szTemp, sGetValueByIdx(szFiled, ",", 3), sizeof(szTemp));
            strncpy(stFiled.szFieldCut, sGetTruckValue(szTemp, "\"", "\""), 
                sizeof(stFiled.szFieldCut));
            if(RC_FAIL == lTransferValue(stFiled.szFieldCut, stFiled.szFieldCut, sizeof(stFiled.szFieldCut), 
                pstCfg))
                sTransCharset(stFiled.szFieldCut);
            stFiled.lFiledPos = atol(sGetValueByIdx(szFiled, ",", 4));
        }
        else
        {
            IBPerror("%s, 文件分割类型设置错误", pszLine);
            return RC_FAIL;
        }
        
        strncpy(stFiled.szExFixFunc, sGetValueByIdx(szFiled, ",", 5), 
            sizeof(stFiled.szExFixFunc));
        sTrimAll(stFiled.szExFixFunc);
    }
    else if('[' == szTemp[0] && ']' == szTemp[l - 1])
    {
        stFiled.lFieldType |= FILE_EXPRESS_VALUE;        //    取值方式中有表达式
        memset(szFiled, 0, sizeof(szFiled));
        strncpy(szFiled, sGetTruckValue(szTemp, "[", "]"), sizeof(szFiled));

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetValueByIdx(szFiled, ",", 1), sizeof(szValue));
        if(RC_SUCC != lSetValueType(szValue, &stFiled.lValueType))
        {
            IBPerror("%s字段%s%s", pszLine, stFiled.szFieldName, sGetError());
            return RC_FAIL;
        }

        p = strstr(szFiled, ",");
        if(!p)    return RC_FAIL;
        strncpy(szTemp, p + strlen(","), sizeof(szTemp));

        memset(szFiled, 0, sizeof(szFiled));
        strncpy(szFiled, sGetTruckValue(szTemp, "(", ")"), sizeof(szFiled));

        if(RC_SUCC != lAnalyseExpress(szFiled, &stFiled, pstCfg))
            return RC_FAIL;
    }
    else if('(' == szTemp[0] && ')' == szTemp[l - 1])
    {
        stFiled.lFieldType |= FILE_COMBINA_VALUE;        //    取值方式中组合
        memset(szFiled, 0, sizeof(szFiled));
        strncpy(szFiled, sGetTruckValue(szTemp, "(", ")"), sizeof(szFiled));

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetValueByIdx(szFiled, ",", 1), sizeof(szValue));
        strncpy(stFiled.stComb.szFmt, sGetValueByIdx(szValue, ":", 2),
            sizeof(stFiled.stComb.szFmt));
        sDropCharset(stFiled.stComb.szFmt, '\"');

        memset(szValue, 0, sizeof(szValue));
        strncpy(szValue, sGetValueByIdx(szFiled, ",", 2), sizeof(szValue));
        if(RC_SUCC != lCheckCombina(szValue, &stFiled.stComb, pstCfg->pstFiled))
        {
            IBPerror("组合字符串:[%s]错误 %s", szValue, sGetError());
            return RC_FAIL;
        }

        strncpy(stFiled.stComb.szExecFunc, sGetValueByIdx(szFiled, ",", 3),
            sizeof(stFiled.stComb.szExecFunc));
        sDropCharset(stFiled.stComb.szExecFunc, '\"');
        sTrimAll(stFiled.stComb.szExecFunc);
    }
    else
    {
//        NAME="DeffPuzzL"
        stFiled.lFieldType |= FILE_VARIETY_VALUE;        //    变量设置
        strncpy(stFiled.szFieldValue, szTemp, sizeof(stFiled.szFieldValue));
        sDropCharset(stFiled.szFieldValue, '\"');
    }

    pstCfg->pstFiled = pInsertFiled(pstCfg->pstFiled, &stFiled, sizeof(stFiled));
    if(!pstCfg->pstFiled)
    {
        IBPerror("%s", sGetError());
        return RC_FAIL;
    }

    return RC_SUCC;
}

/****************************************************************************************
    先初始化系统变量
 ****************************************************************************************/
long    CCups::lInitSysVarList(CupsCfg *pstCfg, long *plId)
{
    long    lId = 0;
    char    szVar[50];

    if(!pstCfg || !plId)    return RC_FAIL;

    lId = *plId;
    memset(szVar, 0, sizeof(szVar));
    strcpy(szVar, "__FILE_SEQ=[FIELD_LONG, ]");
    if(RC_SUCC != lFiledDefine(pstCfg, szVar, ++ lId))
        return RC_FAIL;

    memset(szVar, 0, sizeof(szVar));
    strcpy(szVar, "__FILE_VAILD=[FIELD_LONG, ]");
    if(RC_SUCC != lFiledDefine(pstCfg, szVar, ++ lId))
        return RC_FAIL;

    memset(szVar, 0, sizeof(szVar));
    strcpy(szVar, "__FILE_CONTENT=[FIELD_CHAR, ]");;
    if(RC_SUCC != lFiledDefine(pstCfg, szVar, ++ lId))
        return RC_FAIL;

    memset(szVar, 0, sizeof(szVar));
    strcpy(szVar, "__LOAD_DATE=[FIELD_CHAR, ]");
    if(RC_SUCC != lFiledDefine(pstCfg, szVar, ++ lId))
        return RC_FAIL;

    memset(szVar, 0, sizeof(szVar));
    strcpy(szVar, "__LOAD_ERROR=[FIELD_CHAR, ]");
    if(RC_SUCC != lFiledDefine(pstCfg, szVar, ++ lId))
        return RC_FAIL;

    memset(szVar, 0, sizeof(szVar));
    strcpy(szVar, "__FILE_NAME=[FIELD_CHAR, ]");
    if(RC_SUCC != lFiledDefine(pstCfg, szVar, ++ lId))
        return RC_FAIL;

    *plId = lId;

    return RC_SUCC;
}

/****************************************************************************************
    监控进程主程序
 ****************************************************************************************/
long    CCups::lInitailConfig()
{
    FILE    *fp = NULL;
    long    lLine = 0, lRet = 0, lId = 0;
    BOOL    bBegin = false;
    char    szPath[512], szLine[1024], szTemp[100];
    CupsCfg    stCfg;

    memset(&stCfg, 0, sizeof(stCfg));
    memset(szTemp, 0, sizeof(szTemp));
    memset(szPath, 0, sizeof(szPath));
    snprintf(szPath, sizeof(szPath), "%s/etc/cups.ini", getenv("HOME"));

    if(NULL == (fp = fopen(szPath, "r")))
    {
        IBPerror("打开文件(%s)失败, err:%s", szPath, strerror(errno));
        return RC_FAIL;
    }

    memset(szLine, 0, sizeof(szLine));
    while(fgets(szLine, sizeof(szLine), fp))
    {
        lLine ++;
        sTrimAll(szLine);
        sTrimCRLF(szLine);
        if(0 == strlen(szLine) || '#' ==  szLine[0] || ('/' == szLine[0] 
            && '/' == szLine[1]))
        {
            memset(szLine, 0, sizeof(szLine));
            continue;
        }
        
        if(!bBegin && !strncmp(szLine, "DEFINE:", 7))
        {
            bBegin = true;
            lId = 0;
            memset(szTemp, 0, sizeof(szTemp));
            strncpy(szTemp, sGetValueByIdx(szLine, ":", 2), sizeof(szTemp));
            strncpy(stCfg.szCupsNo, sGetValueByIdx(szTemp, ",", 1), sizeof(stCfg.szCupsNo));
            if(0 == strlen(stCfg.szCupsNo))        
            {
                IBPerror("%s", sGetError());
                goto ErrHandle;
            }

            strncpy(stCfg.szLoadFunc, sGetValueByIdx(szLine, ",", 2), sizeof(stCfg.szLoadFunc));    
            sTrimAll(stCfg.szLoadFunc);
            memset(szLine, 0, sizeof(szLine));

            //    先初始化系统变量
            if(RC_SUCC != lInitSysVarList(&stCfg, &lId))
            {
                IBPerror("%s", sGetError());
                goto ErrHandle;
            }    
            continue;
        }
        else if(bBegin && !strncmp(szLine, "ENDDEF", 7))
        {
            bBegin = false;
            IBPrace("通道(%s)配置加载完毕!", stCfg.szCupsNo);
            g_pstConfig = pInsertList(g_pstConfig, &stCfg, sizeof(stCfg));
            if(!g_pstConfig)
            {
                IBPerror("%s", sGetError());
                goto ErrHandle;
            }
            memset(szLine, 0, sizeof(szLine));
            memset(&stCfg, 0, sizeof(stCfg));
            continue;
        }
        if(!bBegin)
        {
            memset(szLine, 0, sizeof(szLine));
            continue;
        }

        if(!strncmp(szLine, "*ROUTECHECK=", 12))
            lRet = lRouteCheck(&stCfg.stRoute, szLine + 12);
        else if(!strncmp(szLine, "*REVOCATE=", 10))
            lRet = lReserveTxn(&stCfg, szLine + 10);
        else
            lRet = lFiledDefine(&stCfg, szLine, ++ lId);
        if(lRet != RC_SUCC)
        {
            IBPerror("%s, %s", szLine, sGetError());
            goto ErrHandle;
        }    

        continue;
ErrHandle:
    fclose(fp);
    vDestroyConfig(&g_pstConfig);
    return RC_FAIL;
    }
    fclose(fp);

    return RC_SUCC;
}



/****************************************************************************************
    debug字段
 ****************************************************************************************/
void    CCups::vPrintFiledDef(FiledDef *pstFiled)
{
    long        l = 0;
    FiledDef    *pstCur = pstFiled;

    while(pstCur)
    {
        //#1、定长 2、分隔符
        if(FILE_FIXD_VALUE & pstCur->lFieldType)
        {
            fprintf(stdout, "字段序号:[%d], 字段名称:[%s], 字段值:[%s], 字段属性:[%s], "
                "取值方式:[%d], 定长起始位置:[%d], 定长结束位置:[%d], 特殊处理函数:[%s]\n", 
                pstCur->lId, pstCur->szFieldName, pstCur->szFieldValue, sGetValueType(pstCur->lValueType), 
                pstCur->lFieldType, pstCur->lFiledFrom, pstCur->lFiledPos, pstCur->szExFixFunc);
        }
        if(FILE_BLOCK_VALUE & pstCur->lFieldType)
        {
            fprintf(stdout, "字段序号:[%d], 字段名称:[%s], 字段值:[%s], 字段属性:[%s], 分割字符:[%s], "
                "取值方式:[%d], 分割索引:[%d], 特殊处理函数:[%s]\n", pstCur->lId, pstCur->szFieldName, 
                pstCur->szFieldValue, sGetValueType(pstCur->lValueType), pstCur->szFieldCut,
                pstCur->lFieldType, pstCur->lFiledPos, pstCur->szExFixFunc);
        }
        if(FILE_EXPRESS_VALUE & pstCur->lFieldType)    //    表达式 
        {
            //    字段表达式
            if(0 == pstCur->stExp.lNum && ECP_CONST_STRING == pstCur->stExp.lConst)    //    常数
                fprintf(stdout, "表达式字段序号:[%d], 字段名称:[%s], 字段值:[%s], 取值方式:[%d], "
                    "设定常数(%s)\n", pstCur->lId, pstCur->szFieldName, pstCur->szFieldValue, 
                    pstCur->lFieldType, pstCur->szFieldValue);
            else if(0 < pstCur->stExp.lNum && pstCur->stExp.pstIdx)
            {
                if(ECP_CONST_COMBINA == pstCur->stExp.lConst)
                {
                    fprintf(stdout, "表达式字段序号:[%d], 字段名称:[%s], 字段值:[%s], 取值方式:[%d], "
                        "设定字段组合表达式:[$%d", pstCur->lId, pstCur->szFieldName, pstCur->szFieldValue,
                        pstCur->lFieldType, pstCur->stExp.pstIdx[0].lIdx);
                    for(l = 1; l < pstCur->stExp.lNum; l ++)
                        fprintf(stdout, " + $%d", pstCur->stExp.pstIdx[l].lIdx);
                }
                else if(ECP_CONST_LESS == pstCur->stExp.lConst)
                {
                    fprintf(stdout, "表达式字段序号:[%d], 字段名称:[%s], 字段值:[%s], 取值方式:[%d], "
                        "设定比较表达式:[$%d < ", pstCur->lId, pstCur->szFieldName, pstCur->szFieldValue, 
                        pstCur->lFieldType, pstCur->stExp.pstIdx[0].lIdx);
                    for(l = 1; l < pstCur->stExp.lNum; l ++)
                        fprintf(stdout, "$%d", pstCur->stExp.pstIdx[l].lIdx);
                }
                else if(ECP_CONST_STRCMP == pstCur->stExp.lConst)
                {
                    fprintf(stdout, "表达式字段序号:[%d], 字段名称:[%s], 字段值:[%s], 取值方式:[%d], "
                        "设定比较表达式:[$%d , ", pstCur->lId, pstCur->szFieldName, pstCur->szFieldValue, 
                        pstCur->lFieldType, pstCur->stExp.pstIdx[0].lIdx);
                    for(l = 1; l < pstCur->stExp.lNum; l ++)
                        fprintf(stdout, "$%d", pstCur->stExp.pstIdx[l].lIdx);

                }
                else if(ECP_CONST_STRSTR == pstCur->stExp.lConst && pstCur->stExp.lNum > 0)
                {
                    fprintf(stdout, "表达式字段序号:[%d], 字段名称:[%s], 字段值:[%s], 取值方式:[%d], "
                        "设置从字段中[$%d]查找[%s", pstCur->lId, pstCur->szFieldName, pstCur->szFieldValue, 
                        pstCur->lFieldType, pstCur->stExp.pstIdx[0].lIdx, pstCur->stExp.szResult);
                }
                else    //    ECP_CONST_CONDIT
                {
                    fprintf(stdout, "表达式字段序号:[%d], 字段名称:[%s], 取值方式:[%d], 文件域表达式:[$%d", 
                        pstCur->lId, pstCur->szFieldName, pstCur->lFieldType, pstCur->stExp.pstIdx[0].lIdx);
                    for(l = 1; l < pstCur->stExp.lNum; l ++)
                        fprintf(stdout, " + $%d", pstCur->stExp.pstIdx[l].lIdx);
                }
        
                if(ECP_CONST_COMBINA == pstCur->stExp.lConst)
                    fprintf(stdout, "]\n");
                else if(ECP_CONST_LESS == pstCur->stExp.lConst || ECP_CONST_STRCMP == pstCur->stExp.lConst ||
                        ECP_CONST_STRSTR == pstCur->stExp.lConst)
                    fprintf(stdout, "], 匹配值:[%s], 否则:[%s]\n", pstCur->stExp.szIsMatch, pstCur->stExp.szNotMatch);
                else    //    ECP_CONST_CONDIT
                    fprintf(stdout, "=%s], 匹配值:[%s], 否则:[%s]\n", pstCur->stExp.szResult,
                        pstCur->stExp.szIsMatch, pstCur->stExp.szNotMatch);
            }
        }
        if(FILE_COMBINA_VALUE & pstCur->lFieldType)    //    字段组合
        {
            //    字段组合
            if(0 < pstCur->stComb.lNum && pstCur->stComb.plIdx)
            {
                fprintf(stdout, "组合字段序号:[%d], 字段名称:[%s], 字段值:[%s], 取值方式:[%d], "
                    "格式规则(%s), 组合后处理函数[%s], 由字段[$%d", pstCur->lId, pstCur->szFieldName, 
                    pstCur->szFieldValue, pstCur->lFieldType, pstCur->stComb.szFmt, 
                    pstCur->stComb.szExecFunc, pstCur->stComb.plIdx[0]);
                for(l = 1; l < pstCur->stComb.lNum; l ++)
                    fprintf(stdout, ", $%d", pstCur->stComb.plIdx[l]);
                fprintf(stdout, "]组合\n");
            }    
        }
        if(FILE_VARIETY_VALUE & pstCur->lFieldType)    //    变量设置
        {
            fprintf(stdout, "变量字段序号:[%d], 字段名称:[%s], 取值方式:[%d], 数据值:[%s]\n", 
                    pstCur->lId, pstCur->szFieldName, pstCur->lFieldType, pstCur->szFieldValue);
        }

        pstCur = pstCur->pstNext;
    }
}

void    CCups::vPrintReList(Revocate *pstRevc)
{
    long    l = 0;
    ReList    *pstReList = NULL;

    if(!pstRevc)    return ;

    if(pstRevc->lNum > 0)
        fprintf(stdout, "选择对撤销流水处理[%d], 撤销处理函数:[%s], 撤销映射[%d], 映射ID[$%d", 
            pstRevc->bLoad, pstRevc->szRevocFunc, pstRevc->lNum, pstRevc->pstIdx[0].lIdx);
    else
        fprintf(stdout, "选择对撤销流水处理[%d], 撤销处理函数:[%s], 撤销映射[%d]\n",
            pstRevc->bLoad, pstRevc->szRevocFunc, pstRevc->lNum);
    for(l = 1; l < pstRevc->lNum; l ++)
        fprintf(stdout, " + $%d", pstRevc->pstIdx[l].lIdx);
    if(pstRevc->lNum > 0)    fprintf(stdout, "]\n");
        
    pstReList = pstRevc->pstReList;
    while(pstReList)
    {
        fprintf(stdout, "撤销流水(%s)(%s)\n", pstReList->m_szSysRefNo, pstReList->m_szTxDate);
        pstReList = pstReList->pstNext;
    }

    return ;
}

void    CCups::vDebugConfig()
{
    long    i = 0;
    CMList  *pstNode = g_pstConfig;
    CupsCfg    stCfg;

    if(!getenv("DEBUG") || strcmp("1", getenv("DEBUG")))
        return ;

    while(pstNode)
    {
        memcpy(&stCfg, pstNode->m_psvData, sizeof(stCfg));    
        fprintf(stdout, "\n输出第%d个渠道, 装载检查[%s], 配置信息如下:\n", ++i, stCfg.szLoadFunc);
        fprintf(stdout, "\n查找路由定义\n类型:%d, 渠道编号:%s, 渠道商户号:%s, 渠道终端号:%s, "
            "费率检查函数(%s)\n", stCfg.stRoute.lType, stCfg.szCupsNo, stCfg.stRoute.szFd42[0], 
            stCfg.stRoute.szTerm[0], stCfg.stRoute.szFeeCheckFunc);

        vPrintFiledDef(stCfg.pstFiled);
        vPrintReList(&stCfg.stRevoct);

        pstNode = pstNode->pstNext;    
    }
}

void    CCups::vDebugCupTxn(TCupsSucc *pstCups)
{
    IBPdebug("id=%s",pstCups->id);
    IBPdebug("stlm_date=%s",pstCups->stlm_date);
    IBPdebug("tx_date=%s",pstCups->tx_date);
    IBPdebug("tx_time=%s",pstCups->tx_time);
    IBPdebug("trace_no=%s",pstCups->trace_no);
    IBPdebug("cup_key=%s",pstCups->cup_key);
    IBPdebug("result_flag=%s",pstCups->result_flag);
    IBPdebug("channel_no=%s",pstCups->channel_no);
    IBPdebug("term_no=%s",pstCups->term_no);
    IBPdebug("ac_no=%s",pstCups->ac_no);
    IBPdebug("ac_bank_no=%s",pstCups->ac_bank_no);
    IBPdebug("tx_amt=%.2f",pstCups->tx_amt);
    IBPdebug("cup_fee=%.2f",pstCups->cup_fee);
    IBPdebug("tx_code=%s",pstCups->tx_code);
    IBPdebug("sys_ref_no=%s",pstCups->sys_ref_no);
    IBPdebug("brf=%s",pstCups->brf);
    IBPdebug("fill=%s",pstCups->fill);
    IBPdebug("create_time=%s",pstCups->create_time);
    IBPdebug("update_time=%s",pstCups->update_time);
    IBPdebug("res=%s",pstCups->res);
    IBPdebug("channel_nm=%s",pstCups->channel_nm);
    IBPdebug("bank_branch_name=%s\n",pstCups->bank_branch_name);
}

/****************************************************************************************
    打印字段数据    
 ****************************************************************************************/
void    CCups::vPrintValues(FiledDef  *pstFiled)
{
    FiledDef    *pstValue = pstFiled;

    while(pstValue)
    {
        IBPuser("FILED:[%s]VALUE[%s]", pstValue->szFieldName, pstValue->szFieldValue);
        pstValue = pstValue->pstNext;
    }
}

/****************************************************************************************
    对表达式的处理
 ****************************************************************************************/
long    CCups::lParseExpress(FiledDef *pstDef, FiledDef *pstRoot)
{
    char        szValue[512], szTemp[512];
    long        i = 0, j = 0, lLen = 0;
    double        dValue = 0;
    BOOL        bIsTrue = false;
    IdxValue    *pstIdx = NULL;
    
    if(!pstDef || !pstRoot)
    {
        IBPerror("error");
        return RC_FAIL;
    }

    if(!(FILE_EXPRESS_VALUE & pstDef->lFieldType)) //  字段组合
        return RC_SUCC;

    //    对于无表达式，设定的参数不处理
    if(ECP_CONST_STRING == pstDef->stExp.lConst || pstDef->stExp.lNum <= 0)
    {
        pstDef = pstDef->pstNext;
        return RC_SUCC;
    }

    if(ECP_CONST_LESS == pstDef->stExp.lConst || ECP_CONST_STRCMP == pstDef->stExp.lConst ||
        ECP_CONST_OPERATE == pstDef->stExp.lConst)
    {
        memset(szTemp, 0, sizeof(szTemp));
        memset(szValue, 0, sizeof(szValue));
        pstIdx = pstDef->stExp.pstIdx;
        if(NAME_VALUE_TYPE == pstIdx[0].lVType)    //    从文件中取值
            strncpy(szTemp, sGetFiledValue(pstRoot, pstIdx[0].lIdx, NULL), 
                sizeof(szTemp) - 1);
        else        // 该方式目前不支持
            ;

        if(NAME_VALUE_TYPE == pstIdx[1].lVType)    //    从文件中取值
            strncpy(szValue, sGetFiledValue(pstRoot, pstIdx[1].lIdx, NULL), 
                sizeof(szValue) - 1);
        else        // 该方式目前不支持
            ;

        if(ECP_CONST_OPERATE == pstDef->stExp.lConst)
        {
            if('+' == pstDef->stExp.szResult[0])
                dValue = atof(szTemp) + atof(szValue);
            else if('-' == pstDef->stExp.szResult[0])
                dValue = atof(szTemp) - atof(szValue);
            else if('*' == pstDef->stExp.szResult[0])
                dValue = atof(szTemp) * atof(szValue);
            else if('/' == pstDef->stExp.szResult[0])
                dValue = atof(szTemp) / atof(szValue);
            else if('%' == pstDef->stExp.szResult[0])
                dValue = atol(szTemp) % atol(szValue);
            else
                return RC_SUCC;

            if(FIELD_DOUBLE == pstDef->lValueType)
                snprintf(pstDef->szFieldValue, sizeof(pstDef->szFieldValue), "%.3f", dValue);
            else
                snprintf(pstDef->szFieldValue, sizeof(pstDef->szFieldValue), "%ld", (long )dValue);
        }
        else
        {
            if(ECP_CONST_LESS == pstDef->stExp.lConst)
            {
                //    无论使整数还是小数 都用atof来比较
                if(atol(szTemp) < atol(szValue))    bIsTrue = true;
                else                                bIsTrue    = false;
            }
            else if(ECP_CONST_STRCMP == pstDef->stExp.lConst)
            {
                 if(!strcmp(szTemp, szValue))        bIsTrue = true;
                else                                bIsTrue    = false;
            }
        
            if(bIsTrue)
                strncpy(pstDef->szFieldValue, pstDef->stExp.szIsMatch, sizeof(pstDef->szFieldValue));
            else
                strncpy(pstDef->szFieldValue, pstDef->stExp.szNotMatch, sizeof(pstDef->szFieldValue));
        }
    }
    else if(ECP_CONST_CONDIT == pstDef->stExp.lConst || ECP_CONST_COMBINA == pstDef->stExp.lConst ||
        ECP_CONST_STRSTR == pstDef->stExp.lConst || ECP_CONST_SUBSTR == pstDef->stExp.lConst ||
        ECP_CONST_DECODE == pstDef->stExp.lConst || ECP_CONST_LENGTH == pstDef->stExp.lConst)
    {
        memset(szValue, 0, sizeof(szValue));
        for(i = 0, lLen = 0, pstIdx = pstDef->stExp.pstIdx; i < pstDef->stExp.lNum || !pstIdx; i ++)
        {
            if(NAME_VALUE_TYPE == pstIdx[i].lVType)    //    从文件中取值
            {
                strncpy(szValue + lLen, sGetFiledValue(pstRoot, pstIdx[i].lIdx, NULL), 
                    sizeof(szValue) - lLen);
                lLen = strlen(szValue);
            }
            else        // 该方式目前不支持
                ;
        }

        memset(pstDef->szFieldValue, 0, sizeof(pstDef->szFieldValue));
        if(ECP_CONST_COMBINA == pstDef->stExp.lConst)
            strncpy(pstDef->szFieldValue, szValue, sizeof(pstDef->szFieldValue));
        else if(ECP_CONST_STRSTR == pstDef->stExp.lConst || ECP_CONST_DECODE == pstDef->stExp.lConst)
        {
            j =  lGetValidNum(pstDef->stExp.szResult, ";");
            for(i = 1, bIsTrue = false; i <= j && !bIsTrue; i ++)
            {
                memset(szTemp, 0, sizeof(szTemp));
                strncpy(szTemp, sGetValueByIdx(pstDef->stExp.szResult, ";", i), 
                    sizeof(szTemp) - 1);
                if(!strlen(szTemp))    continue;
                if(!strcmp(szTemp, szValue))
                    bIsTrue = true;
            }

            if(ECP_CONST_DECODE == pstDef->stExp.lConst)
            {
                if(bIsTrue)
                    strncpy(pstDef->szFieldValue, sGetValueByIdx(pstDef->stExp.szIsMatch, ";", -- i), 
                        sizeof(pstDef->szFieldValue));
                else
                    strncpy(pstDef->szFieldValue, pstDef->stExp.szNotMatch, sizeof(pstDef->szFieldValue));
            }
            else 
            {
                if(bIsTrue)
                    strncpy(pstDef->szFieldValue, pstDef->stExp.szIsMatch, sizeof(pstDef->szFieldValue));
                else
                    strncpy(pstDef->szFieldValue, pstDef->stExp.szNotMatch, sizeof(pstDef->szFieldValue));
            }
        }
        else if(ECP_CONST_SUBSTR == pstDef->stExp.lConst)
        {
            j = sizeof(pstDef->szFieldValue);
            j = j < pstDef->lFiledPos ? j : pstDef->lFiledPos;
            memcpy(pstDef->szFieldValue, szValue + pstDef->lFiledFrom, j);
        }
        else if(ECP_CONST_LENGTH == pstDef->stExp.lConst)
            sprintf(pstDef->szFieldValue, "%d", strlen(szValue));
        else    
        {
            if(!strcmp(szValue, pstDef->stExp.szResult))    //    如果相等
                strncpy(pstDef->szFieldValue, pstDef->stExp.szIsMatch, sizeof(pstDef->szFieldValue));
            else
                strncpy(pstDef->szFieldValue, pstDef->stExp.szNotMatch, sizeof(pstDef->szFieldValue));
        }
    }
    else
        ;
    
    return RC_SUCC;
}

/****************************************************************************************
    对组合字段的处理
 ****************************************************************************************/
long    CCups::lParseFiledValue(FiledDef *pstRoot)
{
    long        lLen = 0;
    ComFiled    *pstComb = NULL;
    FiledDef    *pstDef = pstRoot;

    while(pstDef)
    {
    //    解析表达式[]中优先, 在启动时，已经检测了，表达式中存在的值必须在自己前面定义
        if(RC_SUCC != lParseExpress(pstDef, pstRoot))
        {
            SYSError(RET_SYSTEM, "处理字段(%s)表达函数失败, err:(%s)", pstDef->szFieldName,
                sGetError());
            return RC_FAIL;
        }

        if(!(FILE_COMBINA_VALUE & pstDef->lFieldType)) //  字段组合
        {
            pstDef = pstDef->pstNext;
            continue;
        }

        lLen = sizeof(pstDef->szFieldValue) - 1;
        memset(pstDef->szFieldValue, 0, sizeof(pstDef->szFieldValue));
        strncpy(pstDef->szFieldValue, sGetCombValues(pstRoot, &pstDef->stComb), lLen);

        if(RC_SUCC != lCallUserFunc(pstDef->stComb.szExecFunc, sGetLoadCups(), sGetLoadDate(),
            pstDef->szFieldValue, &lLen))
        {
            SYSError(RET_SYSTEM, "自定义函数(%s)处理失败, err:(%s)", pstDef->stComb.szExecFunc,
                sGetError());
            return RC_FAIL;
        }

        pstDef = pstDef->pstNext;
    }

    return RC_SUCC;
}

/****************************************************************************************
    初始化渠道流水
 ****************************************************************************************/
long    CCups::lInsertCupTxn(TCupsSucc *pstCups)
{
    EXEC SQL BEGIN DECLARE SECTION;
    TCupsSucc        stCups;
    EXEC SQL END DECLARE SECTION;

    //    设定不装载
    if(bIsIgnore())
    {
        IBPrace("用户设定第(%d)行该笔流水(%s)不装载", lGetLoadLine(), pstCups->id);
        return RC_SUCC;
    }

    if(!pstCups)    return RC_FAIL;

    //    非需要对账的流水，CUP_KEY置空
    if(CUP_SUCC_INIT != pstCups->result_flag[0])
        memset(pstCups->cup_key, 0, sizeof(pstCups->cup_key));            

    memcpy(pstCups->create_time, sGetCurrentTime(), sizeof(pstCups->create_time) - 1);
#if        0
++ g_stLoad.lVaild;
vDebugCupTxn(pstCups);
return RC_SUCC;
#else 
    memcpy(&stCups, pstCups, sizeof(TCupsSucc));
    EXEC SQL 
        INSERT INTO TBL_CUPS_SUCC (ID, STLM_DATE, TX_DATE, TX_TIME, TRACE_NO, CUP_KEY, 
            RESULT_FLAG, CHANNEL_NO, TERM_NO, AC_NO, AC_BANK_NO, TX_AMT, CUP_FEE, TX_CODE, 
            SYS_REF_NO, BRF, FILL, CREATE_TIME, RES, CHANNEL_NM, BANK_BRANCH_NAME)
    VALUES 
        (:stCups.id, :stCups.stlm_date, :stCups.tx_date, :stCups.tx_time, :stCups.trace_no,
        :stCups.cup_key, :stCups.result_flag, :stCups.channel_no, :stCups.term_no, 
        :stCups.ac_no, :stCups.ac_bank_no, :stCups.tx_amt, :stCups.cup_fee, :stCups.tx_code,
        :stCups.sys_ref_no, :stCups.brf, :stCups.fill, :stCups.create_time, :stCups.res,
        :stCups.channel_nm, :stCups.bank_branch_name);
    if(SQLCODE)
    {
        SYSError(RET_DATABASE, "新增渠道流水(%s)数据失败, (%d)(%s)", stCups.id, SQLCODE,
            sDbsError());
        return RC_FAIL;
    }

//    默认一千行提交一次
    if(++ g_stLoad.lVaild % 1000 == 0)
        EXEC SQL COMMIT WORK;
#endif

    return RC_SUCC;
}

/****************************************************************************************
    新增撤销流水记录    
 ****************************************************************************************/
long    CCups::lInitRevocate(CupsCfg *pstCfg)
{
    long        i = 0;
    ReList        stReList;
    Revocate    *pstRevc = NULL;

    if(!bIsRevocate())    return RC_SUCC;
    if(!pstCfg)
    {
        SYSError(RET_SYSTEM, "初始化字段值失败, 配置还未初始化!");
        return RC_FAIL;
    }

    pstRevc = &pstCfg->stRevoct;
    if(2 != pstRevc->lNum)
    {
        SYSError(RET_SYSTEM, "撤销流水字段未定义");
        return RC_FAIL;
    }

    memset(&stReList, 0, sizeof(stReList));
    strncpy(stReList.m_szSysRefNo, sGetFiledValue(pstCfg->pstFiled, pstRevc->pstIdx[0].lIdx, NULL), 
        sizeof(stReList.m_szSysRefNo) - 1);
    strncpy(stReList.m_szTxDate, sGetFiledValue(pstCfg->pstFiled, pstRevc->pstIdx[1].lIdx, NULL), 
        sizeof(stReList.m_szTxDate) - 1);

    if(!(pstRevc->pstReList = pInsertReList(pstRevc->pstReList, &stReList, 
        sizeof(stReList))))
    {
        SYSError(RET_SYSTEM, "新增撤销流水失败, err:%s", sGetError());
        return RC_FAIL;
    }

    if(!pstRevc->bLoad)        //    不需要装载
        vSetIgnore(true);

    return RC_SUCC;
}

/****************************************************************************************
    初始化字段数据
 ****************************************************************************************/
long    CCups::lInitFiledValue(CupsCfg *pstCfg, TCupsSucc *pstCups, char *pszLine)
{
    long            lCopy = 0, lRet = 0, lLen = 0;
    FiledDef        *pstFiled    = NULL;
    Route            *pstRoute    = NULL;

    if(!pstCups || !pstCfg)
    {
        SYSError(RET_SYSTEM, "初始化字段值失败, 配置还未初始化!");
        return RC_FAIL;
    }

    //    先加载字段
    pstRoute = &pstCfg->stRoute;
    pstFiled = pstCfg->pstFiled;
    while(pstFiled)
    {
        if(FILE_FIXD_VALUE == pstFiled->lFieldType)            //    固定取值
        {
            memset(pstFiled->szFieldValue, 0, sizeof(pstFiled->szFieldValue));
            lCopy = sizeof(pstFiled->szFieldValue);
            lCopy = lCopy < pstFiled->lFiledPos ? lCopy : pstFiled->lFiledPos;
            memcpy(pstFiled->szFieldValue, pszLine + pstFiled->lFiledFrom, lCopy);

            sTrimLeft(pstFiled->szFieldValue);
            sTrimRight(pstFiled->szFieldValue);
            if(FIELD_LONG == pstFiled->lValueType || FIELD_DOUBLE == pstFiled->lValueType) 
                sTrimAll(pstFiled->szFieldValue);
        }
        else if(FILE_BLOCK_VALUE == pstFiled->lFieldType)    //    阀值分割符
        {
            if(pstFiled->lFiledPos <= 0)
            {
                pstFiled = pstFiled->pstNext;
                continue;
            }
            memset(pstFiled->szFieldValue, 0, sizeof(pstFiled->szFieldValue));
            strncpy(pstFiled->szFieldValue, sGetValueByIdx(pszLine, pstFiled->szFieldCut, 
                pstFiled->lFiledPos), sizeof(pstFiled->szFieldValue));

            sTrimLeft(pstFiled->szFieldValue);
            sTrimRight(pstFiled->szFieldValue);
        //    sDropCharset(pstFiled->szFieldValue, 
            if(FIELD_LONG == pstFiled->lValueType || FIELD_DOUBLE == pstFiled->lValueType) 
                sTrimAll(pstFiled->szFieldValue);
        }
        else
            ;
        
        if(ECP_CONST_STRING == pstFiled->stExp.lConst)
        {
            if(!strcmp(pstFiled->szFieldName, "__FILE_SEQ"))
                sprintf(pstFiled->szFieldValue, "%d", lGetLoadLine());
            else if(!strcmp(pstFiled->szFieldName, "__FILE_VAILD"))
                sprintf(pstFiled->szFieldValue, "%d", lGetLoadValid());
            else if(!strcmp(pstFiled->szFieldName, "__FILE_CONTENT"))
            {
                memset(pstFiled->szFieldValue, 0, sizeof(pstFiled->szFieldValue));
                strncpy(pstFiled->szFieldValue, sGetLoadContent(), sizeof(pstFiled->szFieldValue));
            }
            else if(!strcmp(pstFiled->szFieldName, "__LOAD_DATE"))
            {
                memset(pstFiled->szFieldValue, 0, sizeof(pstFiled->szFieldValue));
                strncpy(pstFiled->szFieldValue, sGetLoadDate(), sizeof(pstFiled->szFieldValue) - 1);
            }
            else if(!strcmp(pstFiled->szFieldName, "__FILE_NAME"))
            {
                memset(pstFiled->szFieldValue, 0, sizeof(pstFiled->szFieldValue));
                strncpy(pstFiled->szFieldValue, sGetLoadFileName(), sizeof(pstFiled->szFieldValue) - 1);
            }
            else
                ;        
        }

        //    如果存在自己定义的函数, 
        lLen = sizeof(pstFiled->szFieldValue);
        lRet = lCallUserFunc(pstFiled->szExFixFunc, pstCfg->szCupsNo, 
            sGetLoadDate(), pstFiled->szFieldValue, &lLen);
        if(RC_SUCC != lRet)
        {
            SYSError(RET_SYSTEM, "用户自定义函数(%s)失败, err:(%s)", pstFiled->szExFixFunc, 
                sGetError());
            return RC_FAIL;
        }

        if(!strcmp(pstRoute->szCNo[0], pstFiled->szFieldName))
            strncpy(pstRoute->szCNo[1], pstFiled->szFieldValue, sizeof(pstRoute->szCNo[1]));
        else if(!strcmp(pstRoute->szFd42[0], pstFiled->szFieldName))
            strncpy(pstRoute->szFd42[1], pstFiled->szFieldValue, sizeof(pstRoute->szFd42[1]));
        else if(!strcmp(pstRoute->szTerm[0], pstFiled->szFieldName))
            strncpy(pstRoute->szTerm[1], pstFiled->szFieldValue, sizeof(pstRoute->szTerm[1]));

        sTrimAll(pstFiled->szFieldValue);
        pstFiled = pstFiled->pstNext;
    }

    // 本条流水无效, 直接忽略
    if(bIsIgnore())        return RC_IGNORE;

    //    优先处理表达式，组合是对字段的处理， 后续在处理在处理表达式，表达式是对字段数据的判断
    if(RC_SUCC != lParseFiledValue(pstCfg->pstFiled))
        return RC_FAIL;

    //    路由检查 检查商户是否在本平台注册，对注册的处理，对未注册的不处理

    pstFiled = pstCfg->pstFiled;
    while(pstFiled)
    {
        if(!strcmp("__IGNORE", pstFiled->szFieldName) && strlen(pstFiled->szFieldValue) > 0)
        {
            if(0 != atol(pstFiled->szFieldValue))    //    存在多个__IGNORE，取true为最大值
            {
            //    如果这里已经igore了, 意味该笔记录平台完全不处理，
            //    后面也就不需要在处理(路由检查、手续费检查、撤销记录)
                IBPrace("满足用户设定忽略条件, 第(%d)行该笔流水(%s)(%s)不装载, 文件数据如下:\n%s", 
                    lGetLoadLine(), pstRoute->szFd42[1], pstRoute->szTerm[1], sGetLoadContent());
                vSetIgnore(true);
            }
        }
        else if(!strcmp("__REVOCATE", pstFiled->szFieldName) && strlen(pstFiled->szFieldValue) > 0)
        {
            if(0 != atol(pstFiled->szFieldValue))    //    存在多个__REVOCATE，取true为最大值
            {
                vSetRevocate(atol(pstFiled->szFieldValue));
                if (RC_SUCC != lInitRevocate(pstCfg))
                    return RC_FAIL;
            }
        }
        else if(!strcmp("__LOAD_ERROR", pstFiled->szFieldName) && strlen(pstFiled->szFieldValue) > 0)
        {
            if(0 < atol(pstFiled->szFieldValue))
            {
                IBPerror("渠道流水装载错误\n(%s)", pszLine);
                SYSError(RET_SYSTEM, "装载渠道流水满足__LOAD_ERROR错误条件, 自动结束, 处理行(%d)", 
                    lGetLoadLine());
                return RC_FAIL;    
            }
            else
            {
                IBPrace("忽略流水记录:\n%s", pszLine);
                vSetIgnore(true);        //    初始化默认装载流水
                return RC_SUCC;
            }
        }

        lMapCupsValue(pstCups, pstFiled->szFieldName, pstFiled->szFieldValue);
        pstFiled = pstFiled->pstNext;
    }
    strncpy(pstCups->channel_nm, g_stLoad.szCupsName, sizeof(pstCups->channel_nm));

    if(bIsIgnore())        return RC_IGNORE;

    if(RC_SUCC != lCallUserCheck(pstRoute->szFeeCheckFunc, pstCups, NULL))
    {
        SYSError(RET_SYSTEM, "检查渠道(%s)记录行(%d)商户手续费失败, err:%s", 
            sGetLoadCups(), lGetLoadLine(), sGetError());
        return RC_FAIL;
    }

    return lInitRevocate(pstCfg);
}

/****************************************************************************************
    是否为一个正常文件，并且是否可读
 ****************************************************************************************/
BOOL    bFileIsRead(char *pszFile)
{
    struct    stat    st;

    if(!pszFile || !strlen(pszFile))
    {
        IBPerror("file name is null");
        return FALSE;
    }

    if(RC_SUCC != stat(pszFile, &st))
    {
        IBPerror("%s", strerror(errno));
        return FALSE;
    }

    if(!S_ISREG(st.st_mode))
    {
        IBPerror("非正常文件");
        return FALSE;
    }

    if(RC_SUCC != access(pszFile, R_OK))
    {
        IBPerror("%s", strerror(errno));
        return FALSE;
    }

    return TRUE;
}

/************************************************************************************/
/*   声明:  void    vReCycleChild(long lChildProNum)                                */
/*   功能： 回收子进程                                                                */
/*   返回值                                                                            */
/************************************************************************************/
static void    vReCycleChild(long lChildProNum)
{
    int        lStatus = 0;
    pid_t   lChildPid = 0;

    while (lChildProNum)
    {
        lChildPid = wait(&lStatus);

        if (WIFEXITED(lStatus))
        {
            if(RC_SUCC != WEXITSTATUS(lStatus)) //  判断退出返回值
            {
                SYSError(RET_SYSTEM, "进程(%d)处理异常，详见子进程日志!",lChildPid);
            }
            else
                IBPrace("进程(%d)正常结束回收, 返回值:%d.", lChildPid, WEXITSTATUS(lStatus));
        }
        else
        {
            SYSError(RET_SYSTEM, "进程(%d)异常结束回收,返回值:%d.",lChildPid, WEXITSTATUS(lStatus));
        }
        
        lChildProNum--;
    }

    return;
}

void    CCups::vLoadChnCom()
{
    long        lRet = 0;
    FILE        *fp        = NULL;
    CupsCfg     *pstCfg    = NULL;
    EXEC SQL BEGIN DECLARE SECTION;
    TCupsSucc   stCups;
    char        szDate[9], szCups[5];
    EXEC SQL END DECLARE SECTION;
    char        szPath[512], szFile[512];
    GCts        *pstCts = (GCts *)pGetGloble();

    memset(szFile, 0, sizeof(szFile));
    memset(szPath, 0, sizeof(szPath));
    memset(szDate, 0, sizeof(szDate));
    memset(szCups, 0, sizeof(szCups));
    IBPgetstring("BAT_FILE", szFile, "通道文件");
    IBPgetstring("BAT_DATE", szDate, "清算日期");
    IBPgetstring("BAT_CUPSNO", szCups, "通道编号");
    if(IBPIserr())
        return ;

    snprintf(szPath, sizeof(szPath), "%s/%s/%s", getenv("FILEDIR"), szCups, szFile);    
    IBPrace("装载日期(%s)渠道(%s), 文件:%s", szDate, szCups, szPath);

    if(!bFileIsRead(szPath))
    {
        SYSError(RET_SYSTEM, "检查渠道(%s)对账文件(%s)失败, err:%s", szCups, 
            szPath, sGetError());
        return ;
    }

    if(!(pstCfg = pGetCupsCfg(szCups)))
        return ;

    memset(&g_stLoad, 0, sizeof(g_stLoad));
    vSetLoadDate(szDate);
    vSetLoadCups(szCups);
    vSetLoadFileName(szFile);

    vDeleteReList(0, &pstCfg->stRevoct);
    EXEC SQL DELETE FROM TBL_CUPS_SUCC WHERE STLM_DATE = :szDate AND CHANNEL_NO = :szCups;
    if(SQL_UD_ERR)
    {
        SYSError(RET_SYSTEM, "删除渠道(%s)(%s)流水失败, :%s", szDate, 
            szCups, sDbsError());
        return ;
    }
    EXEC SQL COMMIT WORK;

    if(NULL == (fp = fopen(szPath, "r")))
    {
        SYSError(RET_SYSTEM, "打开文件(%s)失败, :%s.", szPath, strerror(errno));
        return ;
    }

    while(fgets(g_stLoad.szLine, sizeof(g_stLoad.szLine), fp))
    {
        g_stLoad.lLine ++;
        sTrimCRLF(g_stLoad.szLine);
        if(strlen(g_stLoad.szLine) == 0 || !bIsLoadLine(pstCfg->szLoadFunc, g_stLoad.szLine))
        {
            IBPLoadInitial();
            continue;
        }
        if(bIsIgnore())    //    装载行里面设置的忽略行
        {
            IBPLoadInitial();
            continue;
        }

        memset(&stCups, 0, sizeof(TCupsSucc));
        lRet = lInitFiledValue(pstCfg, &stCups, g_stLoad.szLine);
        if(RC_SUCC == lRet)
            lRet = lInsertCupTxn(&stCups);
        else if(RC_IGNORE == lRet)        //    明确返回RC_IGNORE
            lRet = RC_SUCC;
        else            //    处理失败
            ;
        if(RC_FAIL == lRet)
        {
            fclose(fp);
            IBPLoadInitial();
            EXEC SQL ROLLBACK WORK;
            return ;
        }

        //    初始化默认装载流水 vSetIgnore(false) 初始化非冲正流水 vSetRevocate(false)
        IBPLoadInitial();
    }
    fclose(fp);
    EXEC SQL COMMIT WORK;
    IBPrace("装载渠(%s)道流水完成，装载日期(%s),本地装载有效条数(%d)", szCups, 
        szDate, g_stLoad.lVaild);

    if(!strcmp("REVOCATE_SYSREF", pstCfg->stRevoct.szRevocFunc))
        lRet = lAbolishCupsTxn(REVOCATE_SYSREF, pstCfg->stRevoct.pstReList);
    else if(!strcmp("REVOCATE_TRACE", pstCfg->stRevoct.szRevocFunc))
        lRet = lAbolishCupsTxn(REVOCATE_TRACE, pstCfg->stRevoct.pstReList);
    else if(!strcmp("REVOCATE_CUPKEY", pstCfg->stRevoct.szRevocFunc))
        lRet = lAbolishCupsTxn(REVOCATE_CUPKEY, pstCfg->stRevoct.pstReList);
    else if(!strcmp("ALPY_REVOCATE_CUPKEY", pstCfg->stRevoct.szRevocFunc))
        lRet = lAlpyAbolishCupsTxn(pstCfg->stRevoct.pstReList);
    else if(!strcmp("lCpnr_AbolishTrade", pstCfg->stRevoct.szRevocFunc))
        lRet = lCpnr_AbolishTrade(pstCfg->stRevoct.pstReList, NULL);
    else
        lRet = lCallUserCheck(pstCfg->stRevoct.szRevocFunc, pstCfg->stRevoct.pstReList, NULL);
    vDeleteReList(0, &pstCfg->stRevoct);
    if(lRet == RC_FAIL)
    {
        IBPerror("撤销流水错误");
        return ;
    }

    IBPrace("渠道(%s)文件(%s)处理完毕!", szCups, szPath);

    return ;
}

/****************************************************************************************
    code end
 ****************************************************************************************/
