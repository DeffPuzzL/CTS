#include "model.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "dbstbl.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA;

#define RANDOM_DEBUG 0

typedef enum
{
    VAR_LONG = 0,
    VAR_DOUBLE,
    VAR_STRING,
    VAR_ARRAY
} VARIABLE_TYPE;

typedef enum
{
    OPER_EQ = 0,
    OPER_UQ,
    OPER_GT,
    OPER_LT,
    OPER_IN,
    OPER_NOT_IN,
    OPER_IS_NULL,
    OPER_NOT_NULL
} OPERATE_TYPE;

typedef struct __reflect
{
    int id;
    char *explain;
} reflect;

static reflect sg_var_type[] =
{
    {VAR_LONG, "long"},
    {VAR_DOUBLE, "double"},
    {VAR_STRING, "string"},
    {VAR_ARRAY, "array"}
};

static reflect sg_oper_type[] =
{
    {OPER_EQ, "eq"},
    {OPER_UQ, "uq"},
    {OPER_GT, "gt"},
    {OPER_LT, "lt"},
    {OPER_IN, "in"},
    {OPER_NOT_IN, "not_in"},
    {OPER_IS_NULL, "is_null"},
    {OPER_NOT_NULL, "not_null"}
};

static reflect sg_table_name[] =
{
    {LMER_CON, "tbl_r_lmer_con"},
    {CHA_CON, "tbl_r_cha_con"},
    {CMER_CON, "tbl_r_cmer_con"}
};

typedef struct __rule_condition
{
    CON_TYPE con_type;
    int model_id;
    int group_id;
    char *attr;
    VARIABLE_TYPE var_type;
    OPERATE_TYPE oper_type;
    int match_flag;
    double double_value;
    char *string_value;
    char **array_value;
    long fail_count;
} rule_condition;

typedef struct __rule_group
{
    int group_id;
    long fail_count;
    rule_condition *con;
} rule_group;

typedef struct __rule_model
{
    int model_id;
    rule_group *grp;
} rule_model;

typedef int (*MODEL_INIT_HANDLER)(rule_model **, CON_TYPE);

typedef struct __model_init_handler
{
    CON_TYPE con_type;
    MODEL_INIT_HANDLER handler;
} model_init_handler;

static int s_init_flag = 0;
static long s_judge_count[CON_COUNT] = {0};
static rule_model *sp_model[CON_COUNT] = {NULL};

static void
route_free(void **ptr)
{
    if (*ptr)
    {
        free(*ptr);
    }

    *ptr = NULL;

    return;
}

static void
__model_destroy(rule_model *p_model)
{
    int i = 0;
    rule_model *p_head = p_model;
    rule_group *p_group = NULL;
    rule_condition *p_condition = NULL;

    if (!p_model)
    {
        return;
    }

    for (; p_model->grp; p_model++)
    {
        for (p_group = p_model->grp; p_group->con; p_group++)
        {
            for (p_condition = p_group->con; p_condition && p_condition->attr; p_condition++)
            {
                route_free((void **)&p_condition->attr);

                route_free((void **)&p_condition->string_value);

                if (p_condition->array_value)
                {
                    for (i = 0; p_condition->array_value[i]; i++)
                    {
                        route_free((void **)&p_condition->array_value[i]);
                    }

                    route_free((void **)&p_condition->array_value);
                }
            }

            route_free((void **)&p_group->con); // free condition
        }

        route_free((void **)&p_model->grp); // free group
    }

    route_free((void **)&p_head); // free model

    return;
}

void
model_destroy()
{
    int i = 0;

    for (i = 0; i < CON_COUNT; i++)
    {
        __model_destroy(sp_model[i]);
        sp_model[i] = NULL;
    }

    s_init_flag = 0;

    return;
}

static void
__model_print(rule_model *p_model)
{
    int i = 0;
    char buffer[1024] = {0};
    rule_group *p_group = NULL;
    rule_condition *p_condition = NULL;

    for (; p_model->grp; p_model++)
    {
        IBPuser("\tmodel:%d =>", p_model->model_id);

        for (p_group = p_model->grp; p_group->con; p_group++)
        {
            IBPuser("\t\tgroup:%d(fail:%ld) =>", p_group->group_id, p_group->fail_count);

            for (p_condition = p_group->con; p_condition->attr; p_condition++)
            {
                switch (p_condition->oper_type)
                {
                    case OPER_EQ:
                    case OPER_UQ:
                    case OPER_IS_NULL:
                    case OPER_NOT_NULL:
                        IBPuser("\t\t\t(%d:%d)conditon:{\"attr\":\"%s\", \"var\":\"%s\", \"oper\":\"%s\", \"value\": \"%s\", \"match_flag\": %d}(fail:%d)",
                                p_condition->model_id, p_condition->group_id, p_condition->attr, sg_var_type[p_condition->var_type].explain,
                                sg_oper_type[p_condition->oper_type].explain, p_condition->string_value, p_condition->match_flag, p_condition->fail_count);
                        break;

                    case OPER_GT:
                    case OPER_LT:
                        IBPuser("\t\t\t(%d:%d)conditon:{\"attr\":\"%s\", \"var\":\"%s\", \"oper\":\"%s\", \"value\": %.2f}(fail:%d)",
                                p_condition->model_id, p_condition->group_id, p_condition->attr, sg_var_type[p_condition->var_type].explain,
                                sg_oper_type[p_condition->oper_type].explain, p_condition->double_value, p_condition->fail_count);
                        break;

                    case OPER_IN:
                    case OPER_NOT_IN:
                        memset(buffer, 0, sizeof(buffer));
                        strcat(buffer, "[");

                        for (i = 0; p_condition->array_value[i]; i++, strcat(buffer, ","))
                        {
                            strcat(buffer, "\"");
                            strcat(buffer, p_condition->array_value[i]);
                            strcat(buffer, "\"");
                        }

                        buffer[strlen(buffer) - 1] = ']';

                        IBPuser("\t\t\t(%d:%d)conditon:{\"attr\":\"%s\", \"var\":\"%s\", \"oper\":\"%s\", \"value\": %s, \"match_flag\": %d}(fail:%d)",
                                p_condition->model_id, p_condition->group_id, p_condition->attr, sg_var_type[p_condition->var_type].explain,
                                sg_oper_type[p_condition->oper_type].explain, buffer, p_condition->match_flag, p_condition->fail_count);

                        break;
                }
            }
        }
    }

    return;
}

void
model_print()
{
    int i = 0;

    IBPuser("model print start...");

    for (i = 0; i < CON_COUNT; i++)
    {
        IBPuser("table:%s", sg_table_name[i].explain);
        __model_print(sp_model[i]);
    }

    IBPuser("model print over!!!");

    return;
}

static int
condition_cmp(const void *p1, const void *p2)
{
    return ((rule_condition *)p2)->fail_count - ((rule_condition *)p1)->fail_count;
}

static int
group_cmp(const void *p1, const void *p2)
{
    return ((rule_group *)p1)->fail_count - ((rule_group *)p2)->fail_count;
}

void
model_sort()
{
    int i = 0;
    int num = 0;
    rule_model *p_model = NULL;
    rule_group *p_group = NULL;
    rule_condition *p_condition = NULL;

    for (i = 0; i < CON_COUNT; i++)
    {
        for (p_model = sp_model[i]; p_model->grp; p_model++)
        {
            for (p_group = p_model->grp; p_group->con; p_group++)
            {
                for (num = 0, p_condition = p_group->con; p_condition->attr; num++, p_condition++);

                qsort(p_group->con, num, sizeof(rule_condition), condition_cmp);
            }

            for (num = 0, p_group = p_model->grp; p_group->con; num++, p_group++);

            qsort(p_model->grp, num, sizeof(rule_group), group_cmp);
        }
    }

    return;
}

static rule_model *
model_get(rule_model *p_model, int model_id)
{
    for (; p_model->grp; p_model++)
    {
        if (p_model->model_id == model_id)
        {
            return p_model;
        }
    }

    return NULL;
}

static int
route_getdouble(rule_condition *p_condition, double *p_value)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char tx_date[9] = {0};
        char cha_nm[5] = {0};
        char cha_modid[13] = {0};
        double double_value;
    EXEC SQL END DECLARE SECTION;

    switch (p_condition->con_type)
    {
        case CHA_CON:
            snprintf(tx_date, sizeof(tx_date), "%s", sGetDate());
            snprintf(cha_modid, sizeof(cha_modid), "%d", p_condition->model_id);
            IBPgetstring("cha_nm", cha_nm, "cha_nm");

            if (!strcasecmp(p_condition->attr, "total_amt"))
            {
                EXEC SQL
                select nvl(sum(csm_amount), 0.00) into :double_value
                  from tbl_r_cmer_record where tx_date = :tx_date and cha_nm = :cha_nm;
            }
            else if (!strcasecmp(p_condition->attr, "total_num"))
            {
                EXEC SQL
                select nvl(sum(csm_num), 0.00) into :double_value
                  from tbl_r_cmer_record where tx_date = :tx_date and cha_nm = :cha_nm;
            }
            else if (!strcasecmp(p_condition->attr, "mod_amt"))
            {
                EXEC SQL
                select nvl(sum(csm_amount), 0.00) into :double_value
                  from tbl_r_cmer_record where tx_date = :tx_date and cha_nm = :cha_nm and cha_modid = :cha_modid;
            }
            else if (!strcasecmp(p_condition->attr, "mod_num"))
            {
                EXEC SQL
                select nvl(sum(csm_num), 0.00) into :double_value
                  from tbl_r_cmer_record where tx_date = :tx_date and cha_nm = :cha_nm and cha_modid = :cha_modid;
            }
            else
            {
                IBPgetdouble(p_condition->attr, &double_value, p_condition->attr);
            }

            break;

        default:
            IBPgetdouble(p_condition->attr, &double_value, p_condition->attr);
            break;
    }

    *p_value = double_value;

    return 0;
}

static int
condition_judge(rule_condition *p_condition)
{
    int i = 0;
    int flag = 0;
    int result = 0;
    long long_value = 0;
    double double_value = 0.00;
    char string_value[128] = {0};

    for (; p_condition->attr; p_condition++)
    {
        switch (p_condition->oper_type)
        {
            case OPER_EQ:
                memset(string_value, 0, sizeof(string_value));
                IBPgetstring(p_condition->attr, string_value, p_condition->attr);

                if (p_condition->match_flag)
                {
                    result = strncmp(string_value, p_condition->string_value, strlen(p_condition->string_value));
                }
                else
                {
                    result = strcmp(string_value, p_condition->string_value);
                }

                if (result)
                {
                    IBPdebug("cond[%s:%s]:%s != %s", p_condition->attr, sg_oper_type[p_condition->oper_type].explain, string_value, p_condition->string_value);
                    p_condition->fail_count++;
                    return -1;
                }

                break;

            case OPER_UQ:
                memset(string_value, 0, sizeof(string_value));
                IBPgetstring(p_condition->attr, string_value, p_condition->attr);

                if (p_condition->match_flag)
                {
                    result = strncmp(string_value, p_condition->string_value, strlen(p_condition->string_value));
                }
                else
                {
                    result = strcmp(string_value, p_condition->string_value);
                }

                if (result)

                {
                    IBPdebug("cond[%s:%s]:%s == %s", p_condition->attr, sg_oper_type[p_condition->oper_type].explain, string_value, p_condition->string_value);
                    p_condition->fail_count++;
                    return -1;
                }

                break;

            case OPER_GT:
                double_value = 0.00;
                route_getdouble(p_condition, &double_value);

                if (double_value < p_condition->double_value)
                {
                    IBPdebug("cond[%s:%s]:%.2f < %.2f", p_condition->attr, sg_oper_type[p_condition->oper_type].explain, double_value, p_condition->double_value);
                    p_condition->fail_count++;
                    return -1;
                }

                break;

            case OPER_LT:
                double_value = 0.00;
                route_getdouble(p_condition, &double_value);

                if (double_value >= p_condition->double_value)
                {
                    IBPdebug("cond[%s:%s]:%.2f >= %.2f", p_condition->attr, sg_oper_type[p_condition->oper_type].explain, double_value, p_condition->double_value);
                    p_condition->fail_count++;
                    return -1;
                }

                break;

            case OPER_IN:
                memset(string_value, 0, sizeof(string_value));
                IBPgetstring(p_condition->attr, string_value, p_condition->attr);

                if (p_condition->match_flag)
                {
                    for (i = 0, flag = 0; p_condition->array_value[i]; i++)
                    {
                        if (!strncmp(string_value, p_condition->array_value[i], strlen(p_condition->array_value[i])))
                        {
                            flag = 1;
                            break;
                        }
                    }
                }
                else
                {
                    for (i = 0, flag = 0; p_condition->array_value[i]; i++)
                    {
                        if (!strcmp(string_value, p_condition->array_value[i]))
                        {
                            flag = 1;
                            break;
                        }
                    }
                }

                if (!flag)
                {
                    IBPdebug("cond[%s:%s]:%s not in array", p_condition->attr, sg_oper_type[p_condition->oper_type].explain, string_value);
                    p_condition->fail_count++;
                    return -1;
                }

                break;

            case OPER_NOT_IN:
                memset(string_value, 0, sizeof(string_value));
                IBPgetstring(p_condition->attr, string_value, p_condition->attr);

                if (p_condition->match_flag)
                {
                    for (i = 0, flag = 0; p_condition->array_value[i]; i++)
                    {
                        if (!strncmp(string_value, p_condition->array_value[i], strlen(p_condition->array_value[i])))
                        {
                            flag = 1;
                            break;
                        }
                    }
                }
                else
                {
                    for (i = 0, flag = 0; p_condition->array_value[i]; i++)
                    {
                        if (!strcmp(string_value, p_condition->array_value[i]))
                        {
                            flag = 1;
                            break;
                        }
                    }
                }

                if (flag)
                {
                    IBPdebug("cond[%s:%s]:%s in array", p_condition->attr, sg_oper_type[p_condition->oper_type].explain, string_value);
                    p_condition->fail_count++;
                    return -1;
                }

                break;

            case OPER_IS_NULL:
                memset(string_value, 0, sizeof(string_value));
                IBPgetstring(p_condition->attr, string_value, p_condition->attr);

                if (strlen(string_value))
                {
                    p_condition->fail_count++;
                    return -1;
                }

                break;

            case OPER_NOT_NULL:
                memset(string_value, 0, sizeof(string_value));
                IBPgetstring(p_condition->attr, string_value, p_condition->attr);

                if (!strlen(string_value))
                {
                    p_condition->fail_count++;
                    return -1;
                }

                break;

            default:
                return -1;
        }
    }

    return 0;
}

int
model_judge(CON_TYPE con_type, int model_id)
{
    rule_model *p_model = NULL;
    rule_group *p_group = NULL;

    if (!(p_model = model_get(sp_model[con_type], model_id)))
    {
        IBPerror("model_get error, model_id:(%d)", model_id);
        return -1;
    }

    s_judge_count[con_type]++;

    // model sort every 20000 times
    if (0 == s_judge_count[LMER_CON] % 20000)
    {
        model_sort();
    }

    for (; p_model->grp; p_model++)
    {
        for (p_group = p_model->grp; p_group->con; p_group->fail_count++, p_group++)
        {
            if (!condition_judge(p_group->con))
            {
                return 0;
            }
        }
    }

    return -1;
}

static OPERATE_TYPE
oper_convert(char *operate)
{
    int i = 0;
    static oper_num = sizeof(sg_oper_type) / sizeof(reflect);

    for (i = 0; i < oper_num; i++)
    {
        if (!strcasecmp(sg_oper_type[i].explain, operate))
        {
            return sg_oper_type[i].id;
        }
    }

    return -1;
}

static int
condition_init(rule_condition *p_condition, char *attr_name, char *operate, char *value, char *match_flag)
{
    int i = 0;
    long count = 0;

    if (!(p_condition->attr = (char *)calloc(sizeof(char), strlen(attr_name) + 1)))
    {
        IBPerror("calloc error, err:(%s)", strerror(errno));
        return -1;
    }

    strcpy(p_condition->attr, attr_name);

    if (0 > (p_condition->oper_type = oper_convert(operate)))
    {
        IBPerror("oper_convert error, operate:(%d)", operate);
        return -1;
    }

    p_condition->match_flag = match_flag[0] - '0';

    switch (p_condition->oper_type)
    {
        case OPER_EQ:
        case OPER_UQ:
            p_condition->var_type = VAR_STRING;

            if (!(p_condition->string_value = (char *)calloc(sizeof(char), strlen(value) + 1)))
            {
                IBPerror("calloc error, err:(%s)", strerror(errno));
                return -1;
            }

            strcpy(p_condition->string_value, value);
            break;

        case OPER_GT:
        case OPER_LT:
            p_condition->var_type = VAR_DOUBLE;
            p_condition->double_value = atof(value);
            break;

        case OPER_IN:
        case OPER_NOT_IN:
            p_condition->var_type = VAR_ARRAY;
            count = lGetRecordNum(value, ",", strlen(value)) + 1;

            if (!(p_condition->array_value = (char **)calloc(sizeof(char *), count + 1)))
            {
                IBPerror("calloc error, err:(%s)", strerror(errno));
                return -1;
            }

            for (i = 0; i < count; i++)
            {
                if (!(p_condition->array_value[i] = (char *)calloc(sizeof(char), 10)))
                {
                    IBPerror("calloc error, err:(%s)", strerror(errno));
                    return -1;
                }

                strcpy(p_condition->array_value[i], sGetValueByIdx(value, ",", i + 1));
            }

            break;

        case OPER_IS_NULL:
        case OPER_NOT_NULL:
            p_condition->var_type = VAR_STRING;
            break;

        default:
            return -1;
    }

#if RANDOM_DEBUG
    p_condition->fail_count = random();
#endif
    return 0;
}

static int
model_init_lmer(rule_model **pp_model, CON_TYPE con_type)
{
    int i = 0;
    long model_id = 0;
    long group_id = 0;
    long model_num = 0;
    long group_num = 0;
    long attr_num = 0;
    rule_model *p_model = NULL;
    rule_model *p_model_cur = NULL;
    rule_group *p_group_cur = NULL;
    rule_condition *p_condition_cur = NULL;

    EXEC SQL BEGIN DECLARE SECTION;
        char status[2] = {0};
        tbl_r_lmer_con_def st_lmer_con;
    EXEC SQL END DECLARE SECTION;

    memset(&st_lmer_con, 0, sizeof(st_lmer_con));

    status[0] = '0';
    EXEC SQL DECLARE model_cur_lmer CURSOR FOR
    select mod_id, grp_num, attr_num, attr_name, oprate, value, match_flag
      from tbl_r_lmer_con
     where grp_status = :status
     order by mod_id, grp_num, attr_num;

    EXEC SQL OPEN model_cur_lmer;

    if (SQLCODE)
    {
        IBPerror("open cursor error, err:(%d)(%s)", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        return -1;
    }

    while (1)
    {
        memset(&st_lmer_con, 0, sizeof(st_lmer_con));
        EXEC SQL FETCH model_cur_lmer INTO
            :st_lmer_con.mod_id, :st_lmer_con.grp_num, :st_lmer_con.attr_num, :st_lmer_con.attr_name, :st_lmer_con.oprate, :st_lmer_con.value, :st_lmer_con.match_flag;

        if (SQLNOTFOUND)
        {
            break;
        }
        else if (SQLCODE)
        {
            IBPerror("fetch cursor error, err:(%d)(%s)", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
            EXEC SQL CLOSE model_cur_lmer;
            return -1;
        }

        if (model_id != st_lmer_con.mod_id)
        {
            // new model
            model_num++;

            if (!(p_model = (rule_model *)realloc(p_model, sizeof(rule_model) * (model_num + 1))))
            {
                IBPerror("realloc error, err:(%s)", strerror(errno));
                return -1;
            }

            p_model_cur = p_model + model_num - 1;

            memset(p_model_cur, 0, sizeof(rule_model) * 2);
            p_model_cur->model_id = st_lmer_con.mod_id;

            group_num = 0;
            attr_num = 0;
            group_id = -1;
            model_id = st_lmer_con.mod_id;
        }

        if (group_id != st_lmer_con.grp_num)
        {
            // new group
            group_num++;

            if (!(p_model_cur->grp = (rule_group *)realloc(p_model_cur->grp, sizeof(rule_group) * (group_num + 1))))
            {
                IBPerror("realloc error, err:(%s)", strerror(errno));
                return -1;
            }

            p_group_cur = p_model_cur->grp + group_num - 1;

            memset(p_group_cur, 0, sizeof(rule_group) * 2);
            p_group_cur->group_id = st_lmer_con.grp_num;
#if RANDOM_DEBUG
            p_group_cur->fail_count = random();
#endif
            attr_num = 0;
            group_id = st_lmer_con.grp_num;
        }

        // new attr
        attr_num++;

        if (!(p_group_cur->con = (rule_condition *)realloc(p_group_cur->con, sizeof(rule_condition) * (attr_num + 1))))
        {
            IBPerror("realloc error, err:(%s)", strerror(errno));
            return -1;
        }

        memset(p_group_cur->con + attr_num - 1, 0, sizeof(rule_condition) * 2);
        (p_group_cur->con + attr_num - 1)->con_type = con_type;
        (p_group_cur->con + attr_num - 1)->model_id = p_model_cur->model_id;
        (p_group_cur->con + attr_num - 1)->group_id = p_group_cur->group_id;

        if (0 != condition_init(p_group_cur->con + attr_num - 1, st_lmer_con.attr_name, st_lmer_con.oprate, st_lmer_con.value, st_lmer_con.match_flag))
        {
            return -1;
        }
    }

    *pp_model = p_model;

    EXEC SQL CLOSE model_cur_lmer;

    return 0;
}

static int
model_init_cha(rule_model **pp_model, CON_TYPE con_type)
{
    int i = 0;
    long model_id = -1;
    long group_id = -1;
    long model_num = 0;
    long group_num = 0;
    long attr_num = 0;
    rule_model *p_model = NULL;
    rule_model *p_model_cur = NULL;
    rule_group *p_group_cur = NULL;
    rule_condition *p_condition_cur = NULL;

    EXEC SQL BEGIN DECLARE SECTION;
        char status[2] = {0};
        tbl_r_cha_con_def st_cha_con;
    EXEC SQL END DECLARE SECTION;

    memset(&st_cha_con, 0, sizeof(st_cha_con));

    status[0] = '0';
    EXEC SQL DECLARE model_cur_cha CURSOR FOR
    select mod_id, grp_num, attr_num, attr_name, oprate, value, match_flag
      from tbl_r_cha_con
     where grp_status = :status
     order by mod_id, grp_num, attr_num;

    EXEC SQL OPEN model_cur_cha;

    if (SQLCODE)
    {
        IBPerror("open cursor error, err:(%d)(%s)", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        return -1;
    }

    while (1)
    {
        memset(&st_cha_con, 0, sizeof(st_cha_con));
        EXEC SQL FETCH model_cur_cha INTO
            :st_cha_con.mod_id, :st_cha_con.grp_num, :st_cha_con.attr_num, :st_cha_con.attr_name, :st_cha_con.oprate, :st_cha_con.value, :st_cha_con.match_flag;

        if (SQLNOTFOUND)
        {
            break;
        }
        else if (SQLCODE)
        {
            IBPerror("fetch cursor error, err:(%d)(%s)", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
            EXEC SQL CLOSE model_cur_cha;
            return -1;
        }

        if (model_id != st_cha_con.mod_id)
        {
            // new model
            model_num++;

            if (!(p_model = (rule_model *)realloc(p_model, sizeof(rule_model) * (model_num + 1))))
            {
                IBPerror("realloc error, err:(%s)", strerror(errno));
                return -1;
            }

            p_model_cur = p_model + model_num - 1;

            memset(p_model_cur, 0, sizeof(rule_model) * 2);
            p_model_cur->model_id = st_cha_con.mod_id;

            group_num = 0;
            attr_num = 0;
            group_id = -1;
            model_id = st_cha_con.mod_id;
        }

        if (group_id != st_cha_con.grp_num)
        {
            // new group
            group_num++;

            if (!(p_model_cur->grp = (rule_group *)realloc(p_model_cur->grp, sizeof(rule_group) * (group_num + 1))))
            {
                IBPerror("realloc error, err:(%s)", strerror(errno));
                return -1;
            }

            p_group_cur = p_model_cur->grp + group_num - 1;

            memset(p_group_cur, 0, sizeof(rule_group) * 2);
            p_group_cur->group_id = st_cha_con.grp_num;
#if RANDOM_DEBUG
            p_group_cur->fail_count = random();
#endif
            attr_num = 0;
            group_id = st_cha_con.grp_num;
        }

        // new attr
        attr_num++;

        if (!(p_group_cur->con = (rule_condition *)realloc(p_group_cur->con, sizeof(rule_condition) * (attr_num + 1))))
        {
            IBPerror("realloc error, err:(%s)", strerror(errno));
            return -1;
        }

        memset(p_group_cur->con + attr_num - 1, 0, sizeof(rule_condition) * 2);
        (p_group_cur->con + attr_num - 1)->con_type = con_type;
        (p_group_cur->con + attr_num - 1)->model_id = p_model_cur->model_id;
        (p_group_cur->con + attr_num - 1)->group_id = p_group_cur->group_id;

        if (0 != condition_init(p_group_cur->con + attr_num - 1, st_cha_con.attr_name, st_cha_con.oprate, st_cha_con.value, st_cha_con.match_flag))
        {
            return -1;
        }
    }

    *pp_model = p_model;

    EXEC SQL CLOSE model_cur_cha;

    return 0;
}

static int
model_init_cmer(rule_model **pp_model, CON_TYPE con_type)
{
    int i = 0;
    long model_id = 0;
    long group_id = 0;
    long model_num = 0;
    long group_num = 0;
    long attr_num = 0;
    rule_model *p_model = NULL;
    rule_model *p_model_cur = NULL;
    rule_group *p_group_cur = NULL;
    rule_condition *p_condition_cur = NULL;

    EXEC SQL BEGIN DECLARE SECTION;
        char status[2] = {0};
        tbl_r_cmer_con_def st_cmer_con;
    EXEC SQL END DECLARE SECTION;

    memset(&st_cmer_con, 0, sizeof(st_cmer_con));

    status[0] = '0';
    EXEC SQL DECLARE model_cur_cmer CURSOR FOR
    select mod_id, grp_num, attr_num, attr_name, oprate, value, match_flag
      from tbl_r_cmer_con
     where grp_status = :status
     order by mod_id, grp_num, attr_num;

    EXEC SQL OPEN model_cur_cmer;

    if (SQLCODE)
    {
        IBPerror("open cursor error, err:(%d)(%s)", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        return -1;
    }

    while (1)
    {
        memset(&st_cmer_con, 0, sizeof(st_cmer_con));
        EXEC SQL FETCH model_cur_cmer INTO
            :st_cmer_con.mod_id, :st_cmer_con.grp_num, :st_cmer_con.attr_num, :st_cmer_con.attr_name, :st_cmer_con.oprate, :st_cmer_con.value, :st_cmer_con.match_flag;

        if (SQLNOTFOUND)
        {
            break;
        }
        else if (SQLCODE)
        {
            IBPerror("fetch cursor error, err:(%d)(%s)", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
            EXEC SQL CLOSE model_cur_cmer;
            return -1;
        }

        if (model_id != st_cmer_con.mod_id)
        {
            // new model
            model_num++;

            if (!(p_model = (rule_model *)realloc(p_model, sizeof(rule_model) * (model_num + 1))))
            {
                IBPerror("realloc error, err:(%s)", strerror(errno));
                return -1;
            }

            p_model_cur = p_model + model_num - 1;

            memset(p_model_cur, 0, sizeof(rule_model) * 2);
            p_model_cur->model_id = st_cmer_con.mod_id;

            group_num = 0;
            attr_num = 0;
            group_id = -1;
            model_id = st_cmer_con.mod_id;
        }

        if (group_id != st_cmer_con.grp_num)
        {
            // new group
            group_num++;

            if (!(p_model_cur->grp = (rule_group *)realloc(p_model_cur->grp, sizeof(rule_group) * (group_num + 1))))
            {
                IBPerror("realloc error, err:(%s)", strerror(errno));
                return -1;
            }

            p_group_cur = p_model_cur->grp + group_num - 1;

            memset(p_group_cur, 0, sizeof(rule_group) * 2);
            p_group_cur->group_id = st_cmer_con.grp_num;
#if RANDOM_DEBUG
            p_group_cur->fail_count = random();
#endif
            attr_num = 0;
            group_id = st_cmer_con.grp_num;
        }

        // new attr
        attr_num++;

        if (!(p_group_cur->con = (rule_condition *)realloc(p_group_cur->con, sizeof(rule_condition) * (attr_num + 1))))
        {
            IBPerror("realloc error, err:(%s)", strerror(errno));
            return -1;
        }

        memset(p_group_cur->con + attr_num - 1, 0, sizeof(rule_condition) * 2);
        (p_group_cur->con + attr_num - 1)->con_type = con_type;
        (p_group_cur->con + attr_num - 1)->model_id = p_model_cur->model_id;
        (p_group_cur->con + attr_num - 1)->group_id = p_group_cur->group_id;

        if (0 != condition_init(p_group_cur->con + attr_num - 1, st_cmer_con.attr_name, st_cmer_con.oprate, st_cmer_con.value, st_cmer_con.match_flag))
        {
            return -1;
        }
    }

    *pp_model = p_model;

    EXEC SQL CLOSE model_cur_cmer;

    return 0;
}

int
model_init()
{
    int i = 0;
    rule_model *p_cur_model[CON_COUNT] = {NULL};
    static model_init_handler init_handler[] =
    {
        {LMER_CON, model_init_lmer},
        {CHA_CON, model_init_cha},
        {CMER_CON, model_init_cmer}
    };

    if (s_init_flag)
    {
        for (i = 0; i < CON_COUNT; i++)
        {
            if (0 != init_handler[i].handler(&p_cur_model[i], i))
            {
                for (; i > -1; i--)
                {
                    __model_destroy(p_cur_model[i]);
                }

                return -1;
            }
        }

        // free old model
        model_destroy();

        for (i = 0; i < CON_COUNT; i++)
        {
            // refresh new model
            s_judge_count[i] = 0;
            sp_model[i] = p_cur_model[i];
        }
    }
    else
    {
        for (i = 0; i < CON_COUNT; i++)
        {
            if (0 != init_handler[i].handler(&sp_model[i], i))
            {
                model_destroy();
                return -1;
            }
        }
    }

    model_print();
    s_init_flag = 1;

    return 0;
}
