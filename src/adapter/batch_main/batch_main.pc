/*************************************************************************************************
    文 件 名  : posp_jsonin.c
    作    者  : DeffPuzzL
    版    本  : V2.0.0.0
    创建日期  : 2016-03-07
    描    述  : 用http报文调用结算接口
 ************************************************************************************************/
#include    "face.h"
EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
EXEC SQL END DECLARE SECTION;

#define RUN_BATCH_NIL                   0x00000000      //  自动下级任务执行
#define RUN_AUTO_NEXT                   0x00000001      //  自动下级任务执行
#define RUN_SNG_BATCH                   0x00000002      //  单个任务
#define RUN_SUB_STASK                   0x00000004      //  子任务模式
#define RUN_BATH_TASK                   (RUN_SNG_BATCH | RUN_SUB_STASK)

#define BATCH_TASK_INIT                 '0'
#define BATCH_TASK_RUN                  '1'
#define BATCH_TASK_SUCC                 '2'
#define BATCH_TASK_END                    '9'
#define BATCH_TASK_FAIL                 '3'
#define BATCH_TASK_PART                 '4'

#define BATCH_CALL_NO                   '0' // 自动大任务模式 
#define BATCH_CALL_AUTO                 '1' // 支持成功后重做 
#define BATCH_CALL_SUB                  '2' // 支持手动发起子任务模式 
#define BATCH_CALL_PAT                  '3' // 支持手动发起单子任务模式
#define BATCH_CALL_TASK                 '4' // 仅仅支持子任务模式发起

#define BATCH_WORK_OFF                  '3' // 非工作日
#define BATCH_WORK_DAY                  '2' // 工作日
#define BATCH_WORK_BRH                  '1' // 分润日

/**************************************************************************************************
 *     全局进程信息
 **************************************************************************************************/
typedef struct
{
    long head_value;
    long head_recv_len;
    long body_recv_len;
    char head[5];
    char body[5000];
}stRecvBuffer;

static stRecvBuffer g_stRecv[2000];

/**************************************************************************************************
    函 数 名：vPrintVersion(char *pszParm)
    功能描述：显示该应用的版本
    返回说明：
        无
 **************************************************************************************************/
void    vPrintVersion(char *pszParm)
{
    if(!pszParm)    return ;
    if(strcmp(sUpper(pszParm), "-V"))   return ;

    fprintf(stdout, "%s\n", g_szVersion);

    exit(0);
}

/**************************************************************************************************
    函 数 名：vErrorReturn(BSock skSock)
    功能描述：接收核心请求事件任务
    返回说明：
        RC_SUCC             --成功
        RC_FAIL             --失败
 **************************************************************************************************/
void    vErrorReturn(BSock skSock)
{
    long    lLen, lWrite = 0;
    char    szWrite[512], szLen[5];

    memset(szLen, 0, sizeof(szLen));
    memset(szWrite, 0, sizeof(szWrite));
    lLen = snprintf(szWrite + 4, sizeof(szWrite) - 4, "100000210{\"ret_code\":\"%s\",\"ret_msg"
        "\":\"%s\"}", sGetRetCode(), sGetRetMsg());
    snprintf(szLen, sizeof(szLen), "%04d", lLen);
    memcpy(szWrite, szLen, 4);
    lWrite = lLen + 4;

    if(lWrite != tcp_send(skSock, szWrite, lWrite, 0))
    {
        IBPerror("发送任务响应失败, err:%s", strerror(errno));
        return ;
    }

    return ;
}

/**************************************************************************************************
    函 数 名：lRecvMessage(BSock skSock, char *pszOut, int lOut, int flag)
    功能描述：接收核心请求事件任务
    返回说明：
        RC_SUCC             --成功
        RC_FAIL             --失败
 **************************************************************************************************/
int     lRecvMessage(int skSock, char *pszOut, int lOut, int flag)
{
    long    lHead = 0;
    long    lBody = 0;
    static  char    szInCode[30] = {0};
    SATvm   *pstSavm = (SATvm *)pGetSATvm();

    if (g_stRecv[skSock].head_recv_len < 4)
    {
        lHead = tcp_recv(skSock, g_stRecv[skSock].head + g_stRecv[skSock].head_recv_len,
            4 - g_stRecv[skSock].head_recv_len, flag);
        if (lHead <= 0)
        {
            memset(&g_stRecv[skSock], 0, sizeof(g_stRecv[skSock]));
            IBPdetail("socket_fd:%d, len:%d, errno:%d", skSock, lHead, errno);
            return lHead;
        }

        g_stRecv[skSock].head_recv_len += lHead;

        if (g_stRecv[skSock].head_recv_len < 4)
        {
            IBPdetail("socket_fd:%d, lHead:%d, %d, head:%s[%02X %02X]", skSock, lHead,
                g_stRecv[skSock].head_recv_len, g_stRecv[skSock].head,
                g_stRecv[skSock].head[0], g_stRecv[skSock].head[1]);
            return lHead;
        }

        g_stRecv[skSock].head_value = atol(g_stRecv[skSock].head);

        if (g_stRecv[skSock].head_value > 4000)
        {
            SYSError(RET_SYSTEM, "报文超长(%ld)", g_stRecv[skSock].head_value);
            vErrorReturn(skSock);
            memset(&g_stRecv[skSock], 0, sizeof(g_stRecv[skSock]));
            return -1;
        }
    }

    if (g_stRecv[skSock].head_value == g_stRecv[skSock].body_recv_len)
    {
        if (0 == lHead)
        {
            memset(&g_stRecv[skSock], 0, sizeof(g_stRecv[skSock]));
        }

        return lHead;
    }

    lBody = tcp_recv(skSock, g_stRecv[skSock].body + g_stRecv[skSock].body_recv_len,
        g_stRecv[skSock].head_value - g_stRecv[skSock].body_recv_len, flag);
    if (lBody <= 0)
    {
        IBPdetail("socket_fd:%d, len:%d, errno:%d", skSock, lHead, errno);
        return lHead;
    }

    g_stRecv[skSock].body_recv_len += lBody;

    if (g_stRecv[skSock].head_value == g_stRecv[skSock].body_recv_len)
    {
        memset(szInCode, 0, sizeof(szInCode));
        strncpy(szInCode, g_stRecv[skSock].body, 9);

        if (RC_SUCC != lInPutRequest(pstSavm, g_stRecv[skSock].body + 9, g_stRecv[skSock].body_recv_len - 9,
            skSock, szInCode, ""))
        {
            vErrorReturn(skSock);
            memset(&g_stRecv[skSock], 0, sizeof(g_stRecv[skSock]));
            return -1;
        }

        return lHead + lBody;
    }

    return lHead + lBody;
}

/**************************************************************************************************
    函 数 名：lWrite_NULL(int nlPort, int skSock, char *szClientIp, int ncPort, char *pszRecv, 
                int nIn)
    功能描述：接收核心请求事件任务
    返回说明：
        RC_SUCC             --成功
        RC_FAIL             --失败
 **************************************************************************************************/
int        lWrite_NULL(int nlPort, int skSock, char *szClientIp, int ncPort, char *pszRecv, int nIn)
{
    return true;
}

long    lGetNextCode(char *pszInCode, char *pszOut, long lOut)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char    szIdx[41], szNext[512];
    char    szDate[9], szNum[5], szCups[5];
    EXEC SQL END DECLARE SECTION;

    memset(szIdx, 0, sizeof(szIdx));
    memset(szNum, 0, sizeof(szNum));
    memset(szDate, 0, sizeof(szDate));
    memset(szCups, 0, sizeof(szCups));
    memset(szNext, 0, sizeof(szNext));
    IBPgetstring("BAT_InNum", szNum, "批次编号");
    IBPgetstring("BAT_InCups", szCups, "通道编号");
    IBPgetstring("BAT_SettleDate", szDate, "清算日期");
    if(IBPIserr())
        return ;

    snprintf(szIdx, sizeof(szIdx), "%s%s%s%s", pszInCode, szDate, szNum, szCups);

    EXEC SQL SELECT BAT_NEXT INTO :szNext FROM TBL_BAT_MAIN_LIST WHERE ID = :szIdx;
    if(SQLCODE)
    {
        SYSError(RET_DATABASE, "获取任务(%s)下级任务编号失败, err:(%s)", pszInCode, sDbsError());
        return ;
    }
    
    sTrimAll(szNext);
    strncpy(pszOut, szNext, lOut); 

    return RC_SUCC;
}

long    lSetBatError(GCts *pstCts)
{
    EXEC SQL BEGIN DECLARE SECTION;
    long    lCost;
    char    szDate[9], szNum[5], szCups[5];
    char    szIdx[41], szRetMsg[256], szStatus[2];
    EXEC SQL END DECLARE SECTION;

    memset(szIdx, 0, sizeof(szIdx));
    memset(szNum, 0, sizeof(szNum));
    memset(szDate, 0, sizeof(szDate));
    memset(szCups, 0, sizeof(szCups));
    memset(szStatus, 0, sizeof(szStatus));
    memset(szRetMsg, 0, sizeof(szRetMsg));
    IBPgetstring("BAT_InNum", szNum, "批次编号");
    IBPgetstring("BAT_InCups", szCups, "通道编号");
    IBPgetstring("BAT_Status", szStatus, "批次状态");
    IBPgetstring("BAT_SettleDate", szDate, "清算日期");
    if(IBPIserr())
        return ;

    if(BATCH_TASK_END == szStatus[0] || BATCH_TASK_SUCC == szStatus[0])
        return ;

    lCost = pstCts->m_lUseTime;
    szStatus[0] = BATCH_TASK_FAIL;
       strncpy(szRetMsg, pstCts->m_szRetMsg, sizeof(szRetMsg));
    snprintf(szIdx, sizeof(szIdx), "%s%s%s%s", pstCts->m_szInCode, szDate, szNum, szCups);

    EXEC SQL UPDATE TBL_BAT_MAIN_LIST SET
        BAT_STATE = :szStatus,
        BAT_MSG   = :szRetMsg,
        BAT_COST  = BAT_COST + :lCost
    WHERE ID = :szIdx;
    if(SQL_UD_ERR || EFFECT_NUM != 1)
    {
        SYSError(RET_DATABASE, "更新主控表(%s)，err:(%d)(%s)", szIdx, SQLCODE, sDbsError());
        return RC_FAIL;
    }

    EXEC SQL COMMIT WORK;

    return RC_SUCC;
}

/**************************************************************************************************
    函 数 名：vCallNextDone(SATvm *pstSavm, GCts *pstCts, char *pszBuffer, long lLen)
    功能描述：调用下级任务
    返回说明：
 **************************************************************************************************/
void    vCallNextDone(SATvm *pstSavm, GCts *pstCts, char *pszBuffer, long lLen)
{
    long    i, n, lBatStep = 0;
    char    szNext[20], szCode[512], szBuffer[1024];

    vResetPool();
    memset(szNext, 0, sizeof(szNext));
    memset(szCode, 0, sizeof(szCode));
    memset(szBuffer, 0, sizeof(szBuffer));
    IBPgetdeflong("BAT_Next", &lBatStep, 0);
    n = snprintf(szBuffer, sizeof(szBuffer), "%s", pszBuffer);
    if(RC_SUCC != lPackRead(pstSavm, pstCts->m_lOutMid, szBuffer, &n))
        return ;

    if(IBPstaterr(pstCts->m_lState))    //    处理失败，无需下级任务
    {
        lSetBatError(pstCts);
        return ;
    }

    if(RUN_SNG_BATCH == lBatStep || RUN_BATCH_NIL == lBatStep)
        return ;

    if(RC_SUCC != lGetNextCode(pstCts->m_szInCode, szCode, sizeof(szCode)))
        return ;

    for(i = 0, n = lGetValidNum(szCode, ":"); i < n; i ++)
    {
        memset(szNext, 0, sizeof(szNext));
        strncpy(szNext, sGetValueByIdx(szCode, ":", i + 1), sizeof(szNext));

        if(RC_SUCC != lInPutRequest(pstSavm, pszBuffer, lLen, pstCts->m_lResv, szNext, ""))
            continue ;
    }

    return ;
}

/**************************************************************************************************
    函 数 名：vGetRespond(void *args)
    功能描述：提高TCP接入并发接入API
    返回说明：
        RC_SUCC         --成功
          RC_FAIL         --失败
 **************************************************************************************************/
void*    vGetRespond(void *args)
{
    GCts        stCts;
    SATvm        stSamo;
    CtsEvent    stEvent;
    CtsProcess  stProcess;
    long        lLen, lWrite;
    char        *pszBuffer = NULL, szMsg[1024];

    pthread_detach(pthread_self());
    memset(szMsg, 0, sizeof(szMsg));
    memset(&stCts, 0, sizeof(GCts));
    memset(&stSamo, 0, sizeof(stSamo));
    memset(&stProcess, 0, sizeof(CtsProcess));
    if(RC_SUCC != lGetProcess(&stSamo, &stProcess, getpid()))
    {
        IBPerror("获取进程(%d)运行信息失败, err:%s", getpid(), sGetError(&stSamo));
        return NULL;
    }

    if(NULL == (pszBuffer = (char *)pGetBuffer()))
    {
        IBPerror("分配启动运行内存(%d)失败, err:%s", lGetRamPool(), strerror(errno));
        return NULL;
    }

    while(1)
    {
        if(RC_SUCC != lInGetRespond(&stSamo, &stCts, &stProcess, &stEvent, pszBuffer, &lLen))
        {
            close(stEvent.m_lResv);    
            memset(&g_stRecv[stEvent.m_lResv], 0, sizeof(stRecvBuffer));
            SYSError(RET_SYSTEM, "获取交易最终响应失败, err:%s", sGetError(&stSamo));
            continue;
        }
    
           if(IBPevcache(stEvent.m_lState))
            continue;

        IBPrace("交易(%s)处理完毕，检查下级交易", stCts.m_szInCode);
        vCallNextDone(&stSamo, &stCts, pszBuffer, lLen);

        lWrite = snprintf(szMsg, sizeof(szMsg), "%04d%s", strlen(stCts.m_szInCode) + lLen, 
            stCts.m_szInCode);
        lLen = MIN(lLen, sizeof(szMsg) - lWrite);
        memcpy(szMsg + lWrite, pszBuffer, lLen);
        lWrite += lLen;

        IBPrace("发送最终响应数据如下(%d):", lWrite);
        IBPcem(szMsg, lWrite);
        if (lWrite != tcp_send(stEvent.m_lResv, szMsg, lWrite, 0))
            IBPerror("发送任务响应失败, err:%s", strerror(errno));

        shutdown(stEvent.m_lResv, SHUT_RDWR);
        close(stEvent.m_lResv);        
        memset(&g_stRecv[stEvent.m_lResv], 0, sizeof(stRecvBuffer));
    }
    
    pthread_exit(NULL);
    return NULL;
}

/**************************************************************************************************
    函 数 名：lProcInitail()
    功能描述：初始化子进程
    返回说明：
        RC_SUCC             --成功
           RC_FAIL             --失败
 **************************************************************************************************/
int        lProcInitail()
{
    pthread_t   tPid = 0;
    CtsProcess  stProcess;

    memset(&stProcess, 0, sizeof(stProcess));
    strcpy(stProcess.m_szPGName, sGetProgram());
    if(RC_SUCC != lRegisterProcess(sGetProgram(), getpid()))
    {   
        fprintf(stderr, "登记任务(%s)的进程失败!\n", sGetProgram());
        exit(RC_FAIL);
    }

    if(RC_SUCC != lInitialDemo(getpid(), &stProcess))
    {
        IBPerror("进程%s启动初始化失败!", sGetProgram());
        return RC_FAIL;
    }

    if(RC_SUCC != lDbsConnect(DBS_BATCH))
    {
        SYSError(RET_DATABASE, "连接数据库失败, err:(%s)", sDbsError())
        return RC_FAIL;
    }

    IBPrace("进程%s启动，当前版本：%s ...", sGetProgram(), g_szVersion);

    fprintf(stdout, "child %s process id=%d ... success\n", sGetProgram(), getpid());
    fflush(stdout);

    if (0 != pthread_create(&tPid, NULL, vGetRespond, NULL))
    {
        fprintf(stderr, "pthread_create error, err:%s.\n", strerror(errno));
        return RC_FAIL;
    }

    return RC_SUCC;
}

/**************************************************************************************************
    函 数 名：main
    功能描述：进程监控主模块
    返回说明：
        RC_SUCC         --成功
           RC_FAIL         --失败
 **************************************************************************************************/
int main(int argc, char *argv[])
{
    int            nPort[2] = {0};
    CtsHost     stHost;
    CtsProcess  stProcess = {0};
    SATvm       *pstSavm = (SATvm *)pGetSATvm();

    memset(&stHost, 0, sizeof(CtsHost));
    memset(&stProcess, 0, sizeof(stProcess));
    if(RC_SUCC != lInitialDemo(getpid(), &stProcess))
    {
        IBPerror("进程%s启动初始化失败!", basename(argv[0]));
        return RC_FAIL;
    }

    if(RC_SUCC != lGetHostByApp(pstSavm, &stHost, stProcess.m_szPGName))
    {
        SYSError(RET_SYSTEM, "获取执行码(%s)对应的主机信息失败, err:%s",
            stProcess.m_szPGName, sGetError(pstSavm));
        return RC_FAIL;
    }

    lUnregisterProcess(&stProcess, getpid());

    nPort[0] = (int)stHost.m_lHostPort;
    if (RC_SUCC != tcp_epoll_multi_run(nPort, 1, (int)stHost.m_lExec, lProcInitail, 
        lRecvMessage, lWrite_NULL))
    {
        IBPerror("启动进程(%s)(%d)，端口(%d)个数(%d)失败, err:%s", basename(argv[0]), getpid(), 
            stHost.m_lHostPort, stHost.m_lExec, strerror(errno));
        fprintf(stderr, "prot %d,%d, tcp_epoll_multi_run error:%s.\n", stHost.m_lHostPort,
            stHost.m_lExec, strerror(errno));
        fflush(stderr);
        exit(-1);
    }

    exit(0);
}

/**************************************************************************************************
    code end
 **************************************************************************************************/
