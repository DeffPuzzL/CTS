/**************************************************************************************************
    文 件 名：auto_query.pcpp
    代码作者：DeffPuzzL
    编写版本：
    创建日期：2016-07-14
    功能描述：代付流水自动查询
 **************************************************************************************************/
#include    "auto_query.h"

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
#include    "tbl_settle_txn.h"
EXEC SQL END DECLARE SECTION;

/**************************************************************************************************
    方法定义
 **************************************************************************************************/
CQuery::stEvent CQuery::m_stEvent[] =
{
    { "", NULL }
};

/**************************************************************************************************
    函 数 名：CQuery()
    功能描述：构造函数
    返回说明：
 **************************************************************************************************/
CQuery::CQuery()
{

}

/**************************************************************************************************
    函 数 名：~CQuery()
    功能描述：析构函数
    返回说明：
 **************************************************************************************************/
CQuery::~CQuery()
{


}

/**************************************************************************************************
    函 数 名：lRunObject(char* in_szClass, char* in_szAction)
    功能描述：运行类中的方法
    返回说明：
        RC_SUCC         --成功
        RC_FAIL         --失败
 **************************************************************************************************/
long    CQuery::lRunObject(char *in_szClass, char *in_szAction)
{
    int     i = 0;
    char    *p, szAction[256];

    memset(szAction, 0, sizeof(szAction));

    if ((p = strstr(in_szAction, "__")) != NULL)
    {
        strncpy(szAction, in_szAction, p - in_szAction);
    }
    else
    {
        strcpy(szAction, in_szAction);
    }

    while (0 != strcmp(m_stEvent[i].m_szName, ""))
    {
        if (0 == strcmp(m_stEvent[i].m_szName, szAction))
        {
            (this->*m_stEvent[i].m_pEvent)();
            return RC_SUCC;
        }

        i++;
    }

    SYSError(RET_SYSTEM, "组件(%s)的事件(%s)没注册", in_szClass, in_szAction);
    return RC_FAIL;
}

/**************************************************************************************************
    函 数 名：vExitFree(void *argv)
    功能描述：进程退出前处理
    返回说明：
        无
 **************************************************************************************************/
void    vExitFree(void *argv)
{
	IBPFree(argv);
}

/************************************************************************************
	函数定义 ：vAutoCheckTxn(SATvm *pstSavm, long lSleep, CtsProcess *pstProcess)
	函数说明 ：遍历监控流水表记录
    返回说明 ：
        RC_SUCC         --成功
        RC_FAIL         --失败
 ************************************************************************************/
void    CQuery::vAutoCheckTxn(SATvm *pstSavm, long lSleep, CtsProcess *pstProcess)
{
	size_t  i, j, lTime, lRows;
	CtsAsyn stAsyn, *pstAsyn = NULL;
    EXEC SQL BEGIN DECLARE SECTION;
	TSettleTxn	stSettle;
    EXEC SQL END DECLARE SECTION;

	memset(&stSettle, 0, sizeof(TSettleTxn));
    pstSavm->pstVoid = NULL;
    pstSavm->lFind   = IDX_SELECT;
    pstSavm->lSize   = sizeof(CtsAsyn);
	pstSavm->tblName = CTS_ASYN_IDENTIFY;
	if(RC_SUCC != lQuery(pstSavm, &lRows, (void **)&pstAsyn))
    {
		if(NO_DATA_FOUND != pstSavm->m_lErrno)	
		{
        	SYSError(RET_SYSTEM, "查询异步标识表失败, %s", sGetTError(pstSavm->m_lErrno));
        	return ;
		}
    }

	for(i = 0, j = 0; i < lRows; i ++)
    {
		lTime = lGetUnixTime() - pstAsyn[i].m_lIdxTime;
		if(lTime < 30 || lTime < (long)pow(2, pstAsyn[i].m_lResv))
			continue;

        ++ j;
		vSetSuccess((GCts *)pGetGloble());
		IBPresetpool();
		memset(&stSettle, 0, sizeof(TSettleTxn));
		strncpy(stSettle.id, pstAsyn[i].m_szIdx, sizeof(stSettle.id));
		EXEC SQL SELECT * INTO :stSettle FROM TBL_SETTLE_TXN WHERE ID = :stSettle.id;
		if(SQLCODE)
		{
            SYSError(RET_SYSTEM, "查询交易(%s)付款账户失败, %s", stSettle.id, sDbsError());
        	lMonitorEventEx(pstSavm, pstProcess, vExitFree, pstAsyn);
            continue;
		}

        IBPputstring("PAY_order", stSettle.pay_order);
        IBPputstring("PAY_mert", stSettle.app_no);
        IBPputstring("PAY_orderdate", stSettle.settle_date);
        IBPputdouble("PAY_amt", stSettle.settle_amt);
        IBPputstring("TR_MertNo", stSettle.pay_acct);
        IBPputstring("TR_Serial", pstAsyn[i].m_szIdx);
		IBPputstring("TR_NotifyUrl", pstAsyn[i].m_szMark);

        IBPrace("监控到未知状态流水(%s)查询次数(%d)", pstAsyn[i].m_szIdx, pstAsyn[i].m_lResv);
		if(RC_FAIL == lStartTrade(pstSavm, pGetCmie(), "200013"))
        {
            SYSError(RET_SYSTEM, "调用新交易(200013)失败, err:%s", sGetError());
        	lMonitorEventEx(pstSavm, pstProcess, vExitFree, pstAsyn);
            continue;
        }
		
		vSetSuccess(pGetGloble());
		memset(stSettle.status, 0, sizeof(stSettle.status));
		IBPgetstring("PAY_status", stSettle.status, "代付流水状态");
    	if(IBPIserr())
			continue;

		if(!strcmp(stSettle.status, "VID0001") || !strcmp(stSettle.status, "VID0002"))
		{
			memcpy(&stAsyn, &pstAsyn[i], sizeof(CtsAsyn));

			stAsyn.m_lResv ++;	//	查询次数+ 1
    		pstSavm->pstVoid = &pstAsyn[i];
			lUpdate(pstSavm, &stAsyn, true);
			continue;
		}

		lDeleteAsyn(pstSavm, &pstAsyn[i]);	//	明确返回或成功
        lMonitorEventEx(pstSavm, pstProcess, vExitFree, pstAsyn);
    }
	IBPFree(pstAsyn);
    IBPrace("本次轮询完毕，处理笔数(%d/%d), 待(%d)秒进行下次轮询!", j, lRows, lSleep);

    return ;
}

/*************************************************************************************************
    code end
**************************************************************************************************/
