/**************************************************************************************************
    文 件 名：demo.pc
    代码作者：DeffPuzzL
    编写版本：
    创建日期：2016-07-14
    功能描述：demo实现业务模块
 **************************************************************************************************/
#include    "algo.h"
#include    "coll_cuptxn.h"

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
#include	"tbl_algo_dtls.h"
#include	"tbl_cups_succ.h"
#include	"tbl_order_err.h"
#include	"tbl_order_succ.h"
EXEC SQL END DECLARE SECTION;


/**************************************************************************************************
    方法定义
 **************************************************************************************************/
CColl::stEvent CColl::m_stEvent[] =
{
    {"txn",  		          &CColl::vCollateDetail },
    {"settle",           	  &CColl::vCollateSettle },
    { "", NULL }
};

/**************************************************************************************************
    函 数 名：CColl()
    功能描述：构造函数
    返回说明：
 **************************************************************************************************/
CColl::CColl()
{

}

/**************************************************************************************************
    函 数 名：~CColl()
    功能描述：析构函数
    返回说明：
 **************************************************************************************************/
CColl::~CColl()
{


}

/**************************************************************************************************
    函 数 名：lRunObject(char* in_szClass, char* in_szAction)
    功能描述：运行类中的方法
    返回说明：
        RC_SUCC         --成功
        RC_FAIL         --失败
 **************************************************************************************************/
long    CColl::lRunObject(char *in_szClass, char *in_szAction)
{
    int     i = 0;
    char    *p, szAction[256];

    memset(szAction, 0, sizeof(szAction));

    if ((p = strstr(in_szAction, "__")) != NULL)
    {
        strncpy(szAction, in_szAction, p - in_szAction);
    }
    else
    {
        strcpy(szAction, in_szAction);
    }

    while (0 != strcmp(m_stEvent[i].m_szName, ""))
    {
        if (0 == strcmp(m_stEvent[i].m_szName, szAction))
        {
            (this->*m_stEvent[i].m_pEvent)();
            return RC_SUCC;
        }

        i++;
    }

    SYSError(RET_SYSTEM, "组件(%s)的事件(%s)没注册", in_szClass, in_szAction);
    return RC_FAIL;
}

/*************************************************************************************************
	 声明  ： vSaveAlgoDtl(TAloDtls *pstAlgoDtl)                               
	 功能  ： 对删除的流水进行备份                                                  
	 参数  ： 输入无                                                                
	返回值 ： 无                                                                    
 *************************************************************************************************/
void    CColl::vSaveAlgoDtl(TAlgoDtls *pstAlgoDtl)
{
    FILE    *fp = NULL;

    IBPrace("保存(%s)数据，文件(%s)", pstAlgoDtl->id, m_szBak);
    if(NULL == (fp = fopen(m_szBak, "a+")))
    {
        IBPerror("打开文件(%s)失败, err:%s", m_szBak, strerror(errno));
        return ;
    }

    fwrite(pstAlgoDtl, sizeof(TAlgoDtls), 1, fp);
    fclose(fp);
}

/**************************************************************************************************
     声明  ： void  vFillStlmErr(TOrderErr *pstErr, TOrderSucc *pstOrder)             
     功能  ： 用本地交易表填充对账差错表结构                                        
     参数  ： 输入无                                                                
    返回值 ： 无                                                                    
 *************************************************************************************************/
void    CColl::vFillStlmErr(TOrderErr *pstErr, TOrderSucc *pstOrder)
{
    pstErr->local_amt  = pstOrder->tx_amt;
    pstErr->card_type  = pstOrder->card_type;
    pstErr->disc_cycle = pstOrder->disc_cycle;
    strncpy(pstErr->tx_date, pstOrder->tx_date, 8);
    strncpy(pstErr->tx_time, pstOrder->tx_time, 8);
    strncpy(pstErr->id, pstOrder->id, sizeof(pstErr->id));
    strncpy(pstErr->channel_no, pstOrder->channel_no, sizeof(pstErr->channel_no));
    strncpy(pstErr->pay_type, pstOrder->pay_type, sizeof(pstErr->pay_type));
    strncpy(pstErr->seq_order, pstOrder->seq_order, sizeof(pstErr->seq_order));
    strncpy(pstErr->bank_code, pstOrder->bank_code, sizeof(pstErr->bank_code));
    strncpy(pstErr->bank_card_no, pstOrder->bank_card_no, sizeof(pstErr->bank_card_no));
    strncpy(pstErr->user_name, pstOrder->user_name, sizeof(pstErr->user_name));
    strncpy(pstErr->bank_acc_type, pstOrder->bank_acc_type, sizeof(pstErr->bank_acc_type));
    strncpy(pstErr->bank_full_name, pstOrder->bank_full_name, sizeof(pstErr->bank_full_name));
    strncpy(pstErr->bank_branch_name, pstOrder->bank_branch_name, sizeof(pstErr->bank_branch_name));
    strncpy(pstErr->bank_areacode, pstOrder->bank_areacode, sizeof(pstErr->bank_areacode));
    strncpy(pstErr->cnaps_no, pstOrder->cnaps_no, sizeof(pstErr->cnaps_no));
    strncpy(pstErr->cnaps_bankno, pstOrder->cnaps_bankno, sizeof(pstErr->cnaps_bankno));
    strncpy(pstErr->currency, pstOrder->currency, sizeof(pstErr->currency));
    strncpy(pstErr->remark, pstOrder->remark, sizeof(pstErr->remark));
    strncpy(pstErr->status, pstOrder->status, sizeof(pstErr->status));
    strncpy(pstErr->vid_respcode, pstOrder->vid_respcode, sizeof(pstErr->vid_respcode));
    strncpy(pstErr->vid_respmsg, pstOrder->vid_respmsg, sizeof(pstErr->vid_respmsg));
    strncpy(pstErr->app_code, pstOrder->app_code, sizeof(pstErr->app_code));
    strncpy(pstErr->mert_no, pstOrder->mert_no, sizeof(pstErr->mert_no));
    strncpy(pstErr->mert_nm, pstOrder->mert_nm, sizeof(pstErr->mert_nm));
    strncpy(pstErr->brh_code, pstOrder->brh_code, sizeof(pstErr->brh_code));
    strncpy(pstErr->cert_type, pstOrder->cert_type, sizeof(pstErr->cert_type));
    strncpy(pstErr->cert_no, pstOrder->cert_no, sizeof(pstErr->cert_no));
    strncpy(pstErr->mobile_no, pstOrder->mobile_no, sizeof(pstErr->mobile_no));
    strncpy(pstErr->order_id, pstOrder->order_id, sizeof(pstErr->order_id));
    strncpy(pstErr->product_code, pstOrder->product_code, sizeof(pstErr->product_code));
    strncpy(pstErr->product_name, pstOrder->product_name, sizeof(pstErr->product_name));
    strncpy(pstErr->pay_kind, pstOrder->pay_kind, sizeof(pstErr->pay_kind));
}

/*************************************************************************************************
	 声明  ： int nGetLocalError(TCupsSucc *pstCups, TOrderErr *pstErr)                 
	 功能  ： 渠道有本地无查找对应本地流水                                          
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 *************************************************************************************************/
int     CColl::nGetLocalError(TCupsSucc *pstCups, TOrderErr *pstErr)
{
    EXEC SQL BEGIN DECLARE SECTION;
    TOrderSucc  stOrder;
    char        szDate[9], szCups[5], szOrder[33];
    EXEC SQL END DECLARE SECTION;

    memset(&stOrder, 0, sizeof(TOrderSucc));
    memset(szDate, 0, sizeof(szDate));
    memset(szCups, 0, sizeof(szCups));
    memset(szOrder, 0, sizeof(szOrder));
	strncpy(szDate, pstCups->tx_date, sizeof(szDate));
	strncpy(szCups, pstCups->channel_no, sizeof(szCups));
	strncpy(szOrder, pstCups->sys_ref_no, sizeof(szOrder));

    IBPrace("渠道多帐:查询渠道(%s)交易日期(%s)订单号(%s)的本地流水", pstCups->channel_no, 
		pstCups->tx_date, szOrder);

    EXEC SQL SELECT * INTO :stOrder FROM TBL_ORDER_SUCC WHERE SEQ_ORDER = :szOrder
		AND TX_DATE = :szDate AND CHANNEL_NO = :szCups;
    if(SQLERR)
    {
        SYSError(RET_DATABASE, "查询本地交易流水失败, err:(%d)(%s)", SQLCODE, sDbsError())
        return RC_FAIL;
    }
    else if(SQLNOTFOUND)
    {
        IBPrace("查询结果:本地无此交易流水, 请核对!");
        pstCups->result_flag[0] = TRADE_TXN_INIT;
        return RC_NOTFOUND;
    }
    else
        ;

    vFillStlmErr(pstErr, &stOrder);
    memcpy(pstErr->seq_order, pstCups->sys_ref_no, sizeof(pstErr->seq_order) - 1);

    return RC_SUCC;
}

/*************************************************************************************************
	 声明  ： int   nIsNAlgoTxn(char *pszId, BOOL *pBol)                            
	 功能  ： 判断该笔流水是否已经清分                                              
	返回值 ： RC_SUCC           --  成功                                            
	          RC_NOTFOUND       --  找不到                                          
	          RC_FAIL           --  失败                                            
 *************************************************************************************************/
int     CColl::nIsNAlgoTxn(char *pszId, TAlgoDtls *pstAlgoDtl, BOOL *pbAlgo, BOOL *pbCom)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char        szId[33];
    TAlgoDtls   stAlgoDtl;
    EXEC SQL END DECLARE SECTION;
    BOOL    bAlgo = false, bCom = false;

    memset(szId, 0, sizeof(szId));
    memset(&stAlgoDtl, 0, sizeof(stAlgoDtl));

    memcpy(szId, pszId, sizeof(szId) - 1);
    EXEC SQL SELECT * INTO :stAlgoDtl FROM TBL_ALGO_DTLS WHERE ID = :szId;
    if(SQLERR)
    {
        SYSError(RET_DATABASE, "查询差错记录(%s)出错, err:(%d)(%s)", szId,
            SQLCODE, sDbsError());
        return RC_FAIL;
    }
    else if(SQLOK)
    {
        bAlgo = true;
        if(ALGO_MCHT_FLAG_SUCC == stAlgoDtl.mcht_flag[0])
            bCom = true;
    }

    if(pbAlgo)  *pbAlgo = bAlgo;
    if(pbCom)   *pbCom = bCom;
    if(pstAlgoDtl)  memcpy(pstAlgoDtl, &stAlgoDtl, sizeof(stAlgoDtl));

    return RC_SUCC;
}

/**************************************************************************************************
	 声明  ： int nMatchError(TOrderErr *pstError, char *pszId)                     
	 功能  ： 以渠道流水和本地核对                                                  
	返回值 ： RC_SUCC           --  成功                                            
	          RC_NOTFOUND       --  找不到                                          
	          RC_FAIL           --  失败                                            
 *************************************************************************************************/
int     CColl::nMatchError(BOOL *pbFind, TOrderErr *pstError, char *pszId)
{
    EXEC SQL BEGIN DECLARE SECTION;
    TOrderErr   stErr;
    char        szId[23];
    EXEC SQL END DECLARE SECTION;

    memset(szId, 0, sizeof(szId));
    memcpy(szId, pszId, sizeof(szId) - 1);

    memset(&stErr, 0, sizeof(stErr));
    EXEC SQL SELECT * INTO :stErr FROM TBL_ORDER_ERR WHERE ID = :szId;
    if(SQLERR)
    {
        SYSError(RET_DATABASE, "查询差错记录(%s)出错, err:(%d)(%s)", szId,
            SQLCODE, sDbsError());
        return RC_FAIL;
    }
    else if(SQLNOTFOUND)
    {
        *pbFind = false;
        return RC_SUCC;
    }

    *pbFind = true;
    sTrimAll(stErr.id);
    sTrimAll(stErr.err_type);
    sTrimAll(stErr.stlm_type);
    sTrimAll(stErr.result_flag);
    memcpy(pstError, &stErr, sizeof(stErr));

    return RC_SUCC;
}

/**************************************************************************************************
	 声明  ： int nSetLocalTxn(char *pszId, char chState)                           
	 功能  ： 判断该笔流水是否已经清分                                              
	返回值 ： RC_SUCC           --  成功                                            
	          RC_NOTFOUND       --  找不到                                          
	          RC_FAIL           --  失败                                            
 **************************************************************************************************/
int     CColl::nSetLocalTxn(char *pszId, char *pszDate, char cState)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char    szFlag[2], szDate[9], szId[23], szTime[15];
    EXEC SQL END DECLARE SECTION;

    memset(szFlag, 0, sizeof(szFlag));
    memset(szId, 0, sizeof(szId));
    memset(szDate, 0, sizeof(szDate));
    memset(szTime, 0, sizeof(szTime));

    if(!strlen(pszId) || !pszId)
        return RC_SUCC;

    szFlag[0] = cState;
    memcpy(szId, pszId, sizeof(szId) - 1);
    memcpy(szDate, pszDate, sizeof(szDate) - 1);
	memcpy(szTime, sGetCurrentTime(), sizeof(szTime) - 1);

    EXEC SQL UPDATE TBL_ORDER_SUCC SET
		RESULT_FLAG = :szFlag,
		STLM_DATE   = :szDate
    WHERE ID = :szId;
    if(SQLCODE)
    {
        SYSError(RET_DATABASE, "设置本地流水(%s)失败, err:(%d)(%s)", szId,
            SQLCODE, sDbsError());
        return RC_FAIL;
    }

    return RC_SUCC;
}

/*************************************************************************************************
	 声明  ： int nLocalErrorTxn(TOrderSucc *pstOrder, char *pszStlmDate, char *pstSettleNum)                                                 
	 功能  ： 本地有渠道无的情况                                                    
	 参数  ： 输入无                                                                
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 *************************************************************************************************/
int     CColl::nLocalErrorTxn(TOrderSucc *pstOrder, char *pszStlmDate, char *pszSettleNum)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char		szFlag[2], szDesc[100];
    TOrderErr	stErr, stCom;
    EXEC SQL END DECLARE SECTION;
    TAlgoDtls	stAlgoDtl;
    BOOL        bError = false, bAlgo = false, bCmt = false;

    memset(&stErr, 0, sizeof(stErr));
    memset(&stCom, 0, sizeof(stCom));
    pstOrder->result_flag[0] = TXN_SUCC_NOTMATCH;

    IBPrace("\"本地有渠道无\"逻辑处理->");

	//  考虑到重复对账或者风控的bug，这里查询一次差错流水
    if(RC_SUCC != nMatchError(&bError, &stErr, pstOrder->id))
    {
        IBPerror("查询差错记录(%s)出错!", pstOrder->id);
        return RC_FAIL;
    }

    memset(&stAlgoDtl, 0, sizeof(stAlgoDtl));
    if(RC_SUCC != nIsNAlgoTxn(pstOrder->id, &stAlgoDtl, &bAlgo, &bCmt))
    {
        IBPerror("检查流水(%s)是否清分失败出错!", pstOrder->id);
        return RC_FAIL;
    }

    IBPrace("查询流水业务状态:ID(%s)BOOL(%d)匹配流水(%s), 清分标识(%d)(%d)(%02X)",
        pstOrder->id, bError, stErr.id, bAlgo, bCmt, stErr.stlm_type[0]);

    memcpy(stCom.stlm_date, pszStlmDate, 8);
    memcpy(stCom.settle_num, pszSettleNum, 4);
    stCom.result_flag[0] = STLM_CUP_NOT_DEAL;
    stCom.err_type[0] = ERR_CUP_FLG_NOTMACHT;
    stCom.stlm_type[0] = STLM_CUP_FLG_POSP;

    stCom.tx_amt = pstOrder->tx_amt;
    stCom.local_amt = pstOrder->tx_amt;
    stErr.tx_amt = pstOrder->tx_amt;
    stErr.local_amt = pstOrder->tx_amt;
    snprintf(stCom.err_desc, sizeof(stCom.err_desc) - 1, "本地有渠道无");
    memcpy(stCom.create_time, sGetCurrentTime(), sizeof(stCom.create_time) - 1);

    if(!bError) //  不存在该笔流水
    {
        vFillStlmErr(&stCom, pstOrder);
        stCom.result_flag[0] = STLM_CUP_NOT_DEAL;

        if(RC_SUCC != nDisposeTxn(&stCom, &stAlgoDtl, bAlgo, bCmt))
        {
            IBPerror("处理错误流水(%s)失败!", stErr.id);
            return RC_FAIL;
        }

        EXEC SQL INSERT INTO TBL_ORDER_ERR VALUES (:stCom);
        if(SQLCODE)
        {
            SYSError(RET_DATABASE, "新增差错流水(%s)失败, err:(%d)(%s)", stErr.id,
                SQLCODE, sDbsError());
            return RC_FAIL;
        }
    }
    else    //  存在
    {
        memcpy(stCom.update_time, stCom.create_time, sizeof(stCom.update_time) - 1);

        if(RC_SUCC != nManageError(&stErr, &stCom))
        {
            IBPerror("更新本地错误流水(%s)失败!", stErr.id);
            return RC_FAIL;
        }
    }

    return nSetLocalTxn(pstOrder->id, pszStlmDate, pstOrder->result_flag[0]);
}

/*************************************************************************************************
	 声明  ： int nFromTxnSucc(char *pszStlmDate, char *pszCupsNo, char *pszSettleNum)
	 功能  ： 从渠道流水开始核对                                                    
	 参数  ： 输入无                                                                
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 *************************************************************************************************/
int     CColl::nFromTxnSucc(char *pszStlmDate, char *pszCupsNo, char *pszSettleNum)
{
    long        lCount = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    TOrderSucc  stOrder;
    char        szDayTime[7], szYDay[9];
    char        szFlag[2], szStlmDate[9], szCups[5];
    EXEC SQL END DECLARE SECTION;

    memset(szFlag, 0, sizeof(szFlag));
    memset(szYDay, 0, sizeof(szYDay));
    memset(szCups, 0, sizeof(szCups));
    memset(szDayTime, 0, sizeof(szDayTime));
    memset(szStlmDate, 0, sizeof(szStlmDate));

    memcpy(szStlmDate, pszStlmDate, 8);
    memcpy(szCups, pszCupsNo, 4);
    memcpy(szYDay, sGetChgDate(pszStlmDate, -1), 8);
//  考虑到渠道时间与本系统时间不一致，导致本地多帐的情况(删除清分数据)
//  memcpy(szDayTime, sGetMinsOfs(IBP_SETTLE_TIME, -5), 6);
    memcpy(szDayTime, IBP_SETTLE_TIME, 6);
    szFlag[0] = TXN_SUCC_INIT;

    EXEC SQL DECLARE Cur_order_succ CURSOR FOR 
        SELECT * FROM TBL_ORDER_SUCC
	WHERE ((TX_DATE = :szYDay AND TX_TIME <= :szDayTime) OR TX_DATE < :szYDay)
        AND CHANNEL_NO = :szCups AND RESULT_FLAG = :szFlag ORDER BY TX_DATE, TX_TIME;

    EXEC SQL OPEN Cur_order_succ;
    if(SQLCODE)
    {
        SYSError(RET_DATABASE, "查询本地待对账流水失败, err:(%d)(%s)", SQLCODE, sDbsError());
        return RC_FAIL;
    }

    while(1)
    {
        memset(&stOrder, 0, sizeof(TOrderSucc));
        EXEC SQL FETCH Cur_order_succ INTO :stOrder;
        if(SQLERR)
        {
            SYSError(RET_DATABASE, "获取本地流水失败, err:(%d)(%s)", SQLCODE, sDbsError());
            EXEC SQL CLOSE Cur_order_succ;
            return RC_FAIL;
        }
        else if(SQLNOTFOUND)
            break;

        if(RC_SUCC != nLocalErrorTxn(&stOrder, pszStlmDate, pszSettleNum))
        {
            IBPerror("核对渠道流水错误, cup_key(%s)!", stOrder.cup_key);
            EXEC SQL CLOSE Cur_order_succ;
            EXEC SQL ROLLBACK WORK;
            return RC_FAIL;
        }

        if((++ lCount % 1000) == 0)
            EXEC SQL COMMIT WORK;
    }
    EXEC SQL CLOSE Cur_order_succ;
    EXEC SQL COMMIT WORK;

    return RC_SUCC;
}

/*************************************************************************************************
	 声明  ： int nDisposeTxn(TOrderErr *pstErr, TAlgoDtls *pstAlgoDtl, BOOL bAlgo, BOOL bCmt)                                          
	 功能  ： 新增差错流水                                                          
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 **************************************************************************************************/
int     CColl::nDisposeTxn(TOrderErr *pstErr, TAlgoDtls *pstAlgoDtl, BOOL bAlgo, BOOL bCmt)
{
    int     iRet = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    char    szId[23], szErr[2], szSucc[2];
    EXEC SQL END DECLARE SECTION;

    memset(szId, 0, sizeof(szId));
    memset(szSucc, 0, sizeof(szSucc));
    memset(szErr, 0, sizeof(szErr));
    if(!bAlgo) return RC_SUCC;

    //  存在清分记录
    if(!bCmt)   //  还未汇总、删除流水
    {
        szErr[0]  = STLM_SUCC_FLG_ERR;
        szSucc[0] = STLM_SUCC_FLG_OK;

        //  流水备份
        IBPrace("清分明细|%s|未汇总，本次对账不平直接删除处理, "
            "同时更新成功表清分标识(%s)", pstErr->id, szErr);
        vSaveAlgoDtl(pstAlgoDtl);
        memcpy(szId, pstErr->id, sizeof(szId) - 1);

        //  删除清分流水
        EXEC SQL DELETE FROM TBL_ALGO_DTL WHERE ID = :szId;
        if(SQL_UD_ERR)
        {
            SYSError(RET_DATABASE, "还未汇总，删除清分流水(%s)失败, err:(%d)(%s)",
                szId, SQLCODE, sDbsError());
            return RC_FAIL;
        }

        EXEC SQL DELETE FROM TBL_ALGO_DTL_ASSIST WHERE ID = :szId;
        if(SQL_UD_ERR)
        {
            SYSError(RET_DATABASE, "还未汇总，删除清分辅助流水(%s)失败, err:(%d)(%s)",
                szId, SQLCODE, sDbsError());
            return RC_FAIL;
        }

        EXEC SQL DELETE FROM TBL_FEE_INF WHERE ID = :szId;
        if(SQL_UD_ERR)
        {
            SYSError(RET_DATABASE, "还未汇总，删除TBL_FEE_INF(%s)失败, err:(%d)(%s)",
                szId, SQLCODE, sDbsError());
            return RC_FAIL;
        }

        //  删除之后必须将tbl_stlm_succ状态修改为差错状态，否则该笔对平之后就无法进入清分
        EXEC SQL UPDATE TBL_STLM_SUCC SET
            RESULT_FLAG = :szErr
        WHERE ID = :szId AND RESULT_FLAG = :szSucc;
        if(SQL_UD_ERR)
        {
            SYSError(RET_DATABASE, "还未汇总，删除清分流水(%s)失败, err:(%d)(%s)",
                szId, SQLCODE, sDbsError());
            return RC_FAIL;
        }
    }

    return RC_SUCC;
}

/**************************************************************************************************
	 声明  ： int nManageError(TOrderErr *pstErr, TOrderErr *pstCom)                
	 功能  ： 更新本地错误流水                                                      
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 **************************************************************************************************/
int    CColl::nManageError(TOrderErr *pstErr, TOrderErr *pstCom)
{
    EXEC SQL BEGIN DECLARE SECTION;
    TOrderErr    stErr;
    EXEC SQL END DECLARE SECTION;

    memcpy(&stErr, pstErr, sizeof(stErr));
    memcpy(stErr.err_desc, pstCom->err_desc, sizeof(stErr.err_desc) - 1);
    memcpy(stErr.stlm_date, pstCom->stlm_date, sizeof(stErr.stlm_date) - 1);
    memcpy(stErr.update_time, pstCom->update_time, sizeof(stErr.update_time) - 1);
    stErr.stlm_type[0] = pstCom->stlm_type[0];
    sTrimAll(stErr.result_flag);
    sTrimAll(stErr.err_desc);

    //  差错表标注该笔交易参与清分或者已经清分，需重新更新该记录待运营处理
    if(STLM_CUP_TO_DONE == pstErr->result_flag[0] ||
        STLM_CUP_SETTLE_SUCC == pstErr->result_flag[0])
    {
        IBPwarn("ID[%s]该笔交易已经处理，重新纳入失败处理!", stErr.id);
        stErr.result_flag[0] = pstCom->result_flag[0];
    }
    else if(STLM_CUP_NOT_DEAL == pstErr->result_flag[0])
    {
        IBPrace("ID[%s]该笔交易未处理，差错状态(%s)(%s)(%s)->(%s)", stErr.id,
            pstErr->result_flag, pstErr->err_type, pstErr->stlm_type, pstCom->stlm_type);
        //  依据优先级规则，商户不正常与对账不平同时存在，修改标志为对账不平
        if(ERR_CUP_MCHT_UNNORMAL == pstErr->err_type[0] && ERR_CUP_NOT_CHECK != stErr.stlm_type[0]
            && STLM_FLG_OK_UNNORMAL != stErr.stlm_type[0])
            stErr.err_type[0] = ERR_CUP_FLG_NOTMACHT;
    }
    else
        IBPrace("ID[%s]该笔交易已经转入人工处理，更新必要字段!", stErr.id);

    //  还未对账过
    if(ERR_CUP_NOT_CHECK == pstErr->stlm_type[0])
    {
        EXEC SQL UPDATE TBL_ORDER_ERR SET
            RESULT_FLAG = :stErr.result_flag,
            STLM_DATE   = :stErr.stlm_date,
            CUP_FEE     = :stErr.cup_fee,
            TX_AMT      = :stErr.tx_amt,
            CUPS_AMT    = :stErr.tx_amt,
            ERR_TYPE    = :stErr.err_type,
            STLM_TYPE   = :stErr.stlm_type,
            ERR_DESC    = :stErr.err_desc,
            UPDATE_TIME = :stErr.update_time
        WHERE ID = :stErr.id;
    }
    else
    {
        EXEC SQL UPDATE TBL_ORDER_ERR SET
            RESULT_FLAG = :stErr.result_flag,
            CUP_FEE     = :stErr.cup_fee,
            TX_AMT      = :stErr.tx_amt,
            CUPS_AMT    = :stErr.tx_amt,
            ERR_TYPE    = :stErr.err_type,
            STLM_TYPE   = :stErr.stlm_type,
            ERR_DESC    = :stErr.err_desc,
            UPDATE_TIME = :stErr.update_time
        WHERE ID = :stErr.id;
    }
    if(SQLCODE)
    {
        SYSError(RET_DATABASE, "更新差错交易(%s)信息表失败, err:(%d)(%s)",
            stErr.id, SQLCODE, sDbsError());
        return RC_FAIL;
    }

    return RC_SUCC;
}

/**************************************************************************************************
	 声明  ： int nUpdateError(TCupsSucc *pstCups, TOrderSucc *pstTxn)              
	 功能  ： 以渠道流水和本地核对                                                  
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 **************************************************************************************************/
int     CColl::nUpdateError(TOrderErr *pstError, TOrderSucc *pstTxn)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char        szFlag[2], szDesc[100];
    TOrderErr   stErr;
    TAlgoDtls   stAlgoDtl;
    EXEC SQL END DECLARE SECTION;
    int         iRet = 0;
    BOOL        bAlgo = false, bError = false, bCmt = false;

    memset(szFlag, 0, sizeof(szFlag));
    memset(szDesc, 0, sizeof(szDesc));
    memset(&stErr, 0, sizeof(stErr));
    memset(&stAlgoDtl, 0, sizeof(stAlgoDtl));

    IBPrace("\"流水对账不平\"逻辑处理->");
    if(RC_SUCC != nMatchError(&bError, &stErr, pstTxn->id))
    {
        IBPerror("查询差错记录(%s)出错!", pstTxn->id);
        return RC_FAIL;
    }

    if(RC_SUCC != nIsNAlgoTxn(pstTxn->id, &stAlgoDtl, &bAlgo, &bCmt))
    {
        IBPerror("检查流水(%s)是否清分失败出错!", pstTxn->id);
        return RC_FAIL;
    }

    IBPrace("查询流水业务状态:ID(%s)差错(%d)清分(%d)汇总(%d)流水",
        pstTxn->id, bError, bAlgo, bCmt);

    strcpy(stErr.stlm_date, pstError->stlm_date);
    if(!bError)
    {
        vFillStlmErr(&stErr, pstTxn);
        stErr.tx_amt = pstError->cups_amt;
        stErr.cups_amt = pstError->cups_amt;
        stErr.cup_fee = pstError->cup_fee;
        strcpy(stErr.stlm_date, pstError->stlm_date);
        strcpy(stErr.result_flag, pstError->result_flag);
        strcpy(stErr.create_time, pstError->create_time);
        strcpy(stErr.stlm_type, pstError->stlm_type);
        strcpy(stErr.settle_num, pstError->settle_num);
        stErr.err_type[0] = ERR_CUP_FLG_NOTMACHT;   //  对账不平
        memcpy(stErr.seq_order, pstTxn->seq_order, sizeof(stErr.seq_order) - 1);
        memcpy(stErr.err_desc, pstError->err_desc, sizeof(stErr.err_desc) - 1);

        iRet = nDisposeTxn(&stErr, &stAlgoDtl, bAlgo, bCmt);
        if(iRet)
        {
            IBPerror("处理错误流水失败, err:(%d)", iRet);
            return RC_FAIL;
        }

        EXEC SQL INSERT INTO TBL_ORDER_ERR VALUES (:stErr);
        if(SQLCODE)
        {
            SYSError(RET_DATABASE, "新增差错流水(%s)失败, err:(%d)(%s)", stErr.id,
                SQLCODE, sDbsError());
            return RC_FAIL;
        }
    }
    else    //  bError  历史有差错记录
    {
        stErr.cups_amt = pstError->tx_amt;
        stErr.cup_fee  = pstError->cup_fee;
        strcpy(pstError->update_time, pstError->create_time);

        iRet = nDisposeTxn(&stErr, &stAlgoDtl, bAlgo, bCmt);
        if(iRet)
        {
            IBPerror("处理错误流水失败, err:(%d)", iRet);
            return RC_FAIL;
        }

        iRet = nManageError(&stErr, pstError);
        if(iRet)
        {
            IBPerror("更新差错流水(%s)失败, err:(%d)", stErr.id, iRet);
            return RC_FAIL;
        }
    }

    return RC_SUCC;
}

/**************************************************************************************************
	 声明  ： int nUpdateSucc(TOrderErr *pstError, TOrderSucc *pstTxn)              
	 功能  ： 以渠道流水和本地核对                                                  
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 **************************************************************************************************/
int     CColl::nUpdateSucc(TOrderErr *pstError, TOrderSucc *pstTxn)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char        szFlag[2];
    TOrderErr   stErr;
    EXEC SQL END DECLARE SECTION;
    BOOL        bAlgo = false, bError = false;

    memset(szFlag, 0, sizeof(szFlag));
    memset(&stErr, 0, sizeof(stErr));

    if(RC_SUCC != nMatchError(&bError, &stErr, pstTxn->id))
    {
        IBPerror("查询差错记录(%s)出错!", pstTxn->id);
        return RC_FAIL;
    }

    //  对平且未发现差错记录, 直接返回成功
    if(!bError)     return RC_SUCC;

    stErr.local_amt = pstTxn->tx_amt;
    stErr.tx_amt = pstError->tx_amt;
    stErr.cups_amt = pstError->cups_amt;
    stErr.cup_fee = pstError->cup_fee;
    strcpy(stErr.stlm_date, pstError->stlm_date);
//  stErr.stlm_type[0] = pstError->stlm_type[0];
    memcpy(stErr.update_time, pstError->create_time, sizeof(stErr.update_time) - 1);
    sTrimAll(stErr.stlm_date);
    sTrimAll(stErr.update_time);
    sTrimAll(stErr.stlm_type);
    sTrimAll(stErr.err_desc);

    if(RC_SUCC != nIsNAlgoTxn(pstTxn->id, NULL, &bAlgo, NULL))
    {
        IBPerror("检查流水(%s)是否清分失败出错!", pstTxn->id);
        return RC_FAIL;
    }

    IBPrace("流水(%s)已对平, 差错标记(%d)清分标示(%d)匹配流水(%s), "
        "状态(0X%02X)对账日期(%s)", pstTxn->id, bError, bAlgo, stErr.id, stErr.stlm_type[0],
        stErr.stlm_date);

    if(STLM_CUP_NOT_DEAL == stErr.result_flag[0])
    {
        if(!bAlgo)
        {
            if(ERR_CUP_FLG_NOTMACHT == stErr.err_type[0])
            {
                stErr.result_flag[0] = STLM_CUP_TO_DONE;
                snprintf(stErr.err_desc, sizeof(stErr.err_desc) - 1,
                    "流水已对平，自动参与清分");
            }
        }
        else
            stErr.result_flag[0] = STLM_CUP_SETTLE_SUCC;
    }

    if(ERR_CUP_NOT_CHECK == stErr.stlm_type[0])     //  未对账
    {
        stErr.stlm_type[0] = pstError->stlm_type[0];

        EXEC SQL UPDATE TBL_ORDER_ERR SET
            RESULT_FLAG = :stErr.result_flag,
            STLM_DATE   = :stErr.stlm_date,
            CUP_FEE     = :stErr.cup_fee,
            TX_AMT      = :stErr.tx_amt,
            CUPS_AMT    = :stErr.cups_amt,
            LOCAL_AMT   = :stErr.local_amt,
            STLM_TYPE   = :stErr.stlm_type,
            ERR_DESC    = :stErr.err_desc,
            UPDATE_TIME = :stErr.update_time
        WHERE ID = :stErr.id;
    }
    else
    {
        stErr.stlm_type[0] = pstError->stlm_type[0];

        EXEC SQL UPDATE TBL_ORDER_ERR SET
            RESULT_FLAG = :stErr.result_flag,
            CUP_FEE     = :stErr.cup_fee,
            TX_AMT      = :stErr.tx_amt,
            CUPS_AMT    = :stErr.cups_amt,
            LOCAL_AMT   = :stErr.local_amt,
            STLM_TYPE   = :stErr.stlm_type,
            ERR_DESC    = :stErr.err_desc,
            UPDATE_TIME = :stErr.update_time
        WHERE ID = :stErr.id;
    }
    if(SQLCODE)
    {
        SYSError(RET_DATABASE, "更新本地对平流水(%s)失败, err:(%d)(%s)", stErr.id,
            SQLCODE, sDbsError());
        return RC_FAIL;
    }

    return RC_SUCC;
}

/*************************************************************************************************
	声明  ： int nCheckTxnList(TCupsSucc *pstCups, TOrderSucc *pstTxn, char *pszStlmDate, char *pszSettleNum)
	功能  ： 以渠道流水和本地核对                                                  
   返回值 ： RC_SUCC   --  成功                                                    
             RC_FAIL   --  失败                                                    
 *************************************************************************************************/
int     CColl::nCheckTxnList(TCupsSucc *pstCups, TOrderSucc *pstTxn, char *pszStlmDate, char *pszSettleNum)
{
    long		lRet = 0;
    TOrderErr	stError;

    memset(&stError, 0, sizeof(stError));
    memcpy(stError.stlm_date, pszStlmDate, 8);
    memcpy(stError.settle_num, pszSettleNum, 4);
    stError.result_flag[0] = STLM_CUP_NOT_DEAL;
    stError.stlm_type[0] = STLM_FLG_OK_UNNORMAL;
    stError.tx_amt = pstCups->tx_amt;
    stError.cups_amt = pstCups->tx_amt;
    stError.cup_fee = pstCups->cup_fee;
    memcpy(stError.create_time, sGetCurrentTime(), sizeof(stError.create_time) - 1);

    pstCups->result_flag[0] = STLM_FLG_OK;
    pstTxn->result_flag[0] = TXN_SUCC_ALGO;

    sTrimAll(pstTxn->id);
    sTrimAll(pstCups->ac_no);
    sTrimAll(pstTxn->bank_card_no);

    if(memcmp(pstCups->ac_no, pstTxn->bank_card_no, 6) != 0 ||
        memcmp(pstCups->ac_no + strlen(pstCups->ac_no) - 4,
            pstTxn->bank_card_no + strlen(pstTxn->bank_card_no) - 4, 4) != 0)
    {
        IBPwarn("流水(%s)对账不平, 账号不匹配:(%s)(%s), error!", pstTxn->id,
            pstCups->ac_no, pstTxn->bank_card_no);
        pstCups->result_flag[0] = ERR_CUP_FLG_NOTMACHT;
        pstTxn->result_flag[0] = TXN_SUCC_NOTMATCH;
        stError.stlm_type[0] = STLM_CUP_FLG_ACCT;
        snprintf(stError.err_desc, sizeof(stError.err_desc) - 1,
            "本地(%s)与渠道(%s)账号不一致", pstTxn->bank_card_no, pstCups->channel_no);
    }

    if(fabs(pstCups->tx_amt - pstTxn->tx_amt) > 0.005)
    {
        IBPwarn("流水(%s)对账不平，金额不一致:(%.2f)(%.2f), error!", pstTxn->id,
            pstCups->tx_amt, pstTxn->tx_amt);
        pstCups->result_flag[0] = ERR_CUP_FLG_NOTMACHT;
        pstTxn->result_flag[0] = TXN_SUCC_NOTMATCH;
        stError.stlm_type[0] = STLM_CUP_FLG_AMT;
        snprintf(stError.err_desc, sizeof(stError.err_desc) - 1,
            "本地(%.2f)与渠道(%.2f)金额不一致", pstTxn->tx_amt, pstCups->tx_amt);
    }

    if(ERR_CUP_FLG_NOTMACHT == pstCups->result_flag[0]) //  未对平
        lRet = nUpdateError(&stError, pstTxn);
    else                                                //  STLM_FLG_OK 对平
        lRet = nUpdateSucc(&stError, pstTxn);
	if(lRet)
	{
		IBPerror("处理对账流水(%s)失败, err:(%d)!", pstTxn->id, lRet);
        return RC_FAIL;
    }

    return RC_SUCC;
}

/*************************************************************************************************
	 声明  ： int nCupsErrorTxn(TCupsSucc *pstCups, TOrderSucc *pstTxn, char *pszStlmDate, char *pszSettleNum)
	 功能  ： 渠道有本地无的情况                                                    
	 参数  ： 输入无                                                                
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 *************************************************************************************************/
int     CColl::nCupsErrorTxn(TCupsSucc *pstCups, TOrderSucc *pstTxn, char *pszStlmDate, char *pszSettleNum)
{
    int         iRet = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    char        szFlag[2], szDesc[100];
    TOrderErr   stErr, stCom;
    long        lRec = 0;
    EXEC SQL END DECLARE SECTION;
    BOOL        bAlgo = false, bError = false;

    memset(szFlag, 0, sizeof(szFlag));
    memset(szDesc, 0, sizeof(szDesc));
    memset(&stErr, 0, sizeof(stErr));
    memset(&stCom, 0, sizeof(stCom));

    //  设置对账不平标识
    pstCups->result_flag[0] = TRADE_TXN_NOTMATCH;
    pstTxn->result_flag[0] = TXN_SUCC_NOTMATCH;

    IBPrace("\"渠道有本地无\"逻辑处理->");
    //  根据渠道流水查找本地流水
    iRet= nGetLocalError(pstCups, &stCom);
    if(RC_FAIL == iRet)
    {
        IBPerror("根据渠道流水(%s)查询本地流水失败!", pstCups->id);
        return RC_FAIL;
    }
    else if(RC_NOTFOUND == iRet)
    {
        IBPrace("渠道流水(%s)异常，根据该笔流水无法查询本地流水, 本期无法处理!",
            pstCups->id);
        return RC_SUCC;
    }
    else
        ;

    if (!strlen(pstTxn->id))
    {
        // 保证长款时id有值, 否则直清通道err表的fee_amt不能更新为tbl_cup_succ的cup_fee
        snprintf(pstTxn->id, sizeof(pstTxn->id), "%s", stCom.id);
        // 保证result_flag有值, 否则长款时tbl_txn_succ的result_flag会被置空
        sTrimAll(pstTxn->id);
    }

    //  考虑到重复对账或者风控的bug，这里查询一次差错流水
    if(RC_SUCC != nMatchError(&bError, &stErr, stCom.id))
    {
        IBPerror("查询差错记录(%s)出错!", stCom.id);
        return RC_FAIL;
    }

    IBPrace("查询流水业务状态:ID(%s)BOOL(%d)匹配流水(%s)", stCom.id,
        bError, stErr.id);

    memcpy(stCom.stlm_date, pszStlmDate, 8);
    memcpy(stCom.settle_num, pszSettleNum, 4);
    stCom.result_flag[0] = STLM_CUP_NOT_DEAL;
    stCom.err_type[0] = ERR_CUP_FLG_NOTMACHT;
    stCom.stlm_type[0] = STLM_CUP_FLG_CUPS;

    stCom.cups_amt = pstCups->tx_amt;
    stCom.tx_amt = pstCups->tx_amt;
    stCom.cup_fee = pstCups->cup_fee;
    stErr.tx_amt = pstCups->tx_amt;
    stErr.cup_fee = pstCups->cup_fee;
    stErr.cups_amt = pstCups->tx_amt;
    snprintf(stCom.err_desc, sizeof(stCom.err_desc) - 1, "渠道有本地无");
    memcpy(stCom.create_time, sGetCurrentTime(), sizeof(stCom.create_time) - 1);

    if(!bError) //  不存在该笔流水
    {
        EXEC SQL INSERT INTO TBL_ORDER_ERR VALUES (:stCom);
        if(SQLCODE)
        {
            SYSError(RET_DATABASE, "新增差错流水(%s)失败, err:(%d)(%s)", stCom.id,
                SQLCODE, sDbsError());
            return RC_FAIL;
        }
    }
    else    //  存在
    {
        memcpy(stCom.update_time, stCom.create_time, sizeof(stCom.update_time) - 1);

        if(RC_SUCC != nManageError(&stErr, &stCom))
        {
            IBPerror("更新差错流水(%s)失败!", stErr.id);
            return RC_FAIL;
        }
    }

    return RC_SUCC;
}

/***************************************************************************************************
     声明  ： int nCheckCupsTxn(TCupsSucc *pstCups, char *pszStlmDate, char *pstSettleNum)          
     功能  ： 以渠道流水和本地核对                                                  
     参数  ： 输入无                                                                
    返回值 ： RC_SUCC   --  成功                                                    
              RC_FAIL   --  失败                                                    
 **************************************************************************************************/
int     CColl::nCheckCupsTxn(TCupsSucc *pstCups, char *pszStlmDate, char *pstSettleNum)
{
    long    	lRet = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    TOrderSucc	stOrder;
    char		szKey[50];
    EXEC SQL END DECLARE SECTION;

    memset(szKey, 0, sizeof(szKey));
    snprintf(szKey, sizeof(szKey), "%s", pstCups->cup_key);

    memset(&stOrder, 0, sizeof(TOrderSucc));
    EXEC SQL SELECT * INTO :stOrder FROM TBL_ORDER_SUCC WHERE CUP_KEY = :szKey;
    if(SQLERR)
    {
        SYSError(RET_DATABASE, "查找本地流水失败, err:(%d)(%s), cup_key(%s)", SQLCODE,
            sDbsError(), pstCups->cup_key);
        return RC_FAIL;
    }

    if(SQLOK)
        lRet = nCheckTxnList(pstCups, &stOrder, pszStlmDate, pstSettleNum);
    else    //  SQLNOTFOUND
        lRet = nCupsErrorTxn(pstCups, &stOrder, pszStlmDate, pstSettleNum);
    if(lRet)
    {
        IBPerror("核对流水出错, err:key(%s)(%s)", pstCups->cup_key, stOrder.id);
        return RC_FAIL;
    }

    return nSetLocalTxn(stOrder.id, pszStlmDate, stOrder.result_flag[0]);
}

/**************************************************************************************************
	 声明  ： int nFromCupsTxn(char *pszStlmDate, char *pszCupsNo, char *pszSettleNum)
	 功能  ： 从渠道流水开始核对                                                    
	 参数  ： 输入无                                                                
	返回值 ： RC_SUCC   --  成功                                                    
	          RC_FAIL   --  失败                                                    
 **************************************************************************************************/
int     CColl::nFromCupsTxn(char *pszStlmDate, char *pszCupsNo, char *pszSettleNum)
{
    long        lCount = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    char        szTime[15], szFlag[2];
    char        szStlmDate[9], szCups[5], szYDay[9];
    TCupsSucc   stCups;
    EXEC SQL END DECLARE SECTION;

    memset(szFlag, 0, sizeof(szFlag));
    memset(szYDay, 0, sizeof(szYDay));
    memset(szCups, 0, sizeof(szCups));
    memset(szTime, 0, sizeof(szTime));
    memset(szStlmDate, 0, sizeof(szStlmDate));

    memcpy(szStlmDate, pszStlmDate, 8);
    memcpy(szCups, pszCupsNo, 4);
    memcpy(szTime, sGetCurrentTime(), sizeof(szTime) - 1);
    memcpy(szYDay, sGetChgDate(pszStlmDate, -1), 8);;
    szFlag[0] = TRADE_TXN_INIT;

    //  获取渠道待对账的流水
    EXEC SQL DECLARE Cur_cups_succ CURSOR FOR
        SELECT * FROM TBL_CUPS_SUCC WHERE STLM_DATE <= :szStlmDate AND CHANNEL_NO = :szCups
    AND RESULT_FLAG = :szFlag AND TX_DATE < :szStlmDate ORDER BY TX_DATE, TX_TIME;

    EXEC SQL OPEN Cur_cups_succ;
    if(SQLCODE)
    {
        SYSError(RET_DATABASE, "查询渠道流水失败, err:(%d)(%s)", SQLCODE, sDbsError());
        return RC_FAIL;
    }

    while(1)
    {
        memset(&stCups, 0, sizeof(stCups));
        EXEC SQL FETCH Cur_cups_succ INTO :stCups;
        if(SQLERR)
        {
            SYSError(RET_DATABASE, "获取渠道流水失败, err:(%d)(%s)", SQLCODE, sDbsError());
            EXEC SQL CLOSE Cur_cups_succ;
            return RC_FAIL;
        }
        else if(SQLNOTFOUND)
            break;

        //  以防渠道流水垮天，和系统时间差异引起的不平, 将在下周期对账
        if((0 < memcmp(stCups.tx_time, "235000", 6) && 0 == memcmp(stCups.tx_date, szYDay, 8))
            || 0 < memcmp(stCups.tx_date, szYDay, 8))
            continue;

        if(RC_SUCC != nCheckCupsTxn(&stCups, pszStlmDate, pszSettleNum))
        {
            IBPerror("核对渠道流水错误, cup_key(%s)!", stCups.cup_key);
            EXEC SQL CLOSE Cur_cups_succ;
            EXEC SQL ROLLBACK WORK;
            return RC_FAIL;
        }

        EXEC SQL UPDATE TBL_CUPS_SUCC SET
            RESULT_FLAG = :stCups.result_flag,
            UPDATE_TIME = :szTime
        WHERE ID = :stCups.id;
        if(SQLCODE)
        {
            SYSError(RET_DATABASE, "更新渠道流水失败, err:(%d)(%s), id(%s)", SQLCODE,
                sDbsError(), stCups.id);
            return RC_FAIL;
        }

        if((++ lCount % 1000) == 0)
            EXEC SQL COMMIT WORK;
    }
    EXEC SQL CLOSE Cur_cups_succ;
    EXEC SQL COMMIT WORK;

    return RC_SUCC;
}

/**************************************************************************************************
    函 数 名：vCollateDetail()
    功能描述：交易流水对账
    返回说明：
        无
 **************************************************************************************************/
void    CColl::vCollateDetail()
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	szDate[9], szNum[5], szCups[5];
	EXEC SQL END DECLARE SECTION;

	memset(szNum, 0, sizeof(szNum));
	memset(szDate, 0, sizeof(szDate));
	memset(szCups, 0, sizeof(szCups));
    memset(m_szBak, 0, sizeof(m_szBak));
	IBPgetstring("BAT_InNum", szNum, "批次编号");
	IBPgetstring("BAT_InCups", szCups, "通道编号");
	IBPgetstring("BAT_SettleDate", szDate, "清算日期");
    if(IBPIserr())
        return ;

    snprintf(m_szBak, sizeof(m_szBak), "%s/TBL_ALGO_DTLS.%s.DEL", getenv("POOL_FILE_PATH"),
        szDate);

    if(RC_SUCC != nFromCupsTxn(szDate, szCups, szNum))
        return ;

    if(RC_SUCC != nFromTxnSucc(szDate, szCups, szNum))
        return ;

	return ;
}

/**************************************************************************************************
    函 数 名：vCollateSettle()
    功能描述：代发流水对账
    返回说明：
        无
 **************************************************************************************************/
void    CColl::vCollateSettle()
{
	EXEC SQL BEGIN DECLARE SECTION;
	char		szLine[2048], szFlag[2], szFile[512];
	EXEC SQL END DECLARE SECTION;



    return ;
}

/*************************************************************************************************
    code end
**************************************************************************************************/
