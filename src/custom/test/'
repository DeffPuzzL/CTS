#include	"face.h"

CtsFlow	g_stFlow = {0};

long    nParseExpress(Express *pstExp, char *pszExpress)
{
    char    *p = NULL;
    char    szCondition[128];

    memset(szCondition, 0, sizeof(szCondition));
    if(!strncmp(pszExpress, "if", 2))       //  目前就只是支持IF
    {
        pstExp->m_lConst = EXP_CONST_CONDIT;
        if(NULL == (p = sGetBlockValue(pszExpress, "(", ")")))
        {
            IBPerror("解析表达式(%s)失败!", pszExpress);
            return RC_FAIL;
        }

        strcpy(szCondition, sGetValueByIdx(p, ",", 1));
        strcpy(pstExp->m_szIsMatch, sGetValueByIdx(p, ",", 2));
        strcpy(pstExp->m_szNotMatch, sGetValueByIdx(p, ",", 3));
        sDropCharset(pstExp->m_szIsMatch, '\"');
        sDropCharset(pstExp->m_szNotMatch, '\"');

        pstExp->m_lField = 2;
        if(pstExp->m_lField > MAX_EXPRESS)
            return RC_FAIL;

        strcpy(pstExp->m_szField[0], sGetValueByIdx(szCondition, "=", 1));
        strcpy(pstExp->m_szField[1], sGetValueByIdx(szCondition, "=", 2));
        sDropCharset(pstExp->m_szField[0], '\"');
        sDropCharset(pstExp->m_szField[1], '\"');
    }
    else
        return RC_FAIL;

    return RC_SUCC;
}

char*	sTrimLegal(char *p)
{
	BOOL	bf = false;
	int		i, n, j, k, m;

	if(!p || 0 == (n = strlen(p)))
		return NULL;

	for(i = 0, j = 0, k = 0; i < n; i ++)
	{
		if(p[i] == '\"')
		{
			bf = !bf;
			continue;
		}

		if(bf)	continue;

		if(p[i] == '(')
			j ++;
		if(p[i] == ')')
			k ++;
	}

	if(j != k) return NULL;

	return strimfield(p);
}

/*
char*	sPickupFiled(char *s, char *o)
{
	long	i, j, f;
	char	*p = NULL, n[TARGET_VALUE_LEN], q[TARGET_VALUE_LEN];

	memset(q, 0, sizeof(q));
	memset(n, 0, sizeof(n));
	if(!s || 0 == (j = strlen(s)))	return s;
	if(strncmp(s, "if(", 3) && strncmp(s, "strcmp(", 7) && strncmp(s, "strcpy(", 7) && 
		strncmp(s, "strcat(", 7) && strncmp(s, "atol(", 5) && strncmp(s, "substr(", 7))
		return s;
		
	for(i = 0, f = 0, p = strstr(s, "(") + 1; i < (j - (p - s)) && p; i ++)
	{
		if(p[i] == '(')
			f ++;
		if(p[i] == ')')
		{
			if(0 == f)
			{
				memcpy(q, p, MIN(TARGET_VALUE_LEN, i));
				strcpy(o, sGetValueByIdx(q, ",", 1));
				strcpy(n, sGetValueByIdx(q, ",", 2));
				memcpy(q, s, p - s - 1);
				q[p - s - 1] = 0x00;	
				fprintf(stderr, "RESULT:=======%s:(%s--%s)==\n", q, o, n);
				return o;
			}
			else if(0 == --f)
			{
				++ i;
				break;
			}
		}
	}

	memcpy(q, p, MIN(TARGET_VALUE_LEN, i));
fprintf(stderr, "=======%s\n", q);
	sPickupFiled(q, o);

	fprintf(stderr, "=======%s==%s--%s==\n", q, o, n);
	return o;
}
*/

/*

char*	sPickupFunc(char *s, char *o, long *r)
{
	long	i, j, f;
	Express	*pstExpress = NULL;
	char	*p = NULL, m[TARGET_VALUE_LEN], n[TARGET_VALUE_LEN];

	memset(q, 0, sizeof(q));
	if(NULL != o)
	{


	}
	else
	{
		o = sPickupFunc(q, o, r);
	}

	if(!s || 0 == (j = strlen(s)))	return NULL;

	if(strncmp(s, "if(", 3) && strncmp(s, "strcmp(", 7) && strncmp(s, "strcpy(", 7) && 
		strncmp(s, "strcat(", 7) && strncmp(s, "atol(", 5) && strncmp(s, "substr(", 7))
		return NULL;
	
//	strcmp(strcat(fds,fds),strcat(fdsg,fdsgds))
//	strcmp(fds,fdsgds)

	for(i = 0, f = 0, p = strstr(s, "(") + 1; i < (j - (p - s)) && p; i ++)
	{
		if(p[i] == '(')
			f ++;
		if(p[i] == ')')
		{
			if(0 == f)
			{
				memcpy(q, p, MIN(TARGET_VALUE_LEN, i));
				strcpy(o, sGetValueByIdx(q, ";", 1));
				strcpy(n, sGetValueByIdx(q, ";", 2));
				fprintf(stderr, "RESULT:=======%s==%s--%s==\n", q, o, n);
				return o;
			}
			else if(0 == --f)
			{
				++ i;
				break;
			}
		}
	}

	memcpy(q, p, MIN(TARGET_VALUE_LEN, i));

	fprintf(stderr, "=======%s==%s--%s==\n", q, o, n);
	return o;
//	return sPickupFunc(q, o, r);
}

*/
/*


char*	sPaseExpComb(char *s)
{
	char	*p = strimabout(s, "(", ")");

	if(!p)	return RC_SUCC;
	
	fprintf(stdout, "===%s\n", p);

	return sPaseExpComb(s);
}


*/




long	lExchangeFiled(char *s, long *plRet)
{



	return RC_SUCC;
} 

char*	sGetExpField(char *s, char *o, long n)
{
	char	*p;
	long	l;

	if(!s || NULL == (p = strstr(s, "(")) || 0 == (l = strlen(p)))
		return o;
	
	strncpy(o, p, l - 1);	
	o[l] = 0x00;

	return o;
}


long	_lParseExpress(char *s, long *plRet)
{
	Express	*pstExpress = NULL;
	char	szField[TARGET_VALUE_LEN];

	if(RC_SUCC != lExchangeFiled(s, plRet))
		return *plRet;

	if(MAX_EXPRESS <= g_stFlow.m_lExp)
		return RC_FAIL;

	sGetExpField(s, szField, sizeof(szField));
	pstExpress = &g_stFlow.m_stExp[g_stFlow.m_lExp ++];
	if(!strncmp(s, "if($$", 5))
	{
		pstExpress->m_lField = 2;
		pstExpress->m_lConst = EXP_CONST_STRING;
		strcpy(pstExpress->m_szField[0], sfieldvalue(szField, "=", 1));
		strcpy(szField, sfieldvalue(szField, "=", 2));
		strcpy(pstExpress->m_szField[1], sfieldvalue(szField, ",", 1));
		strcpy(pstExpress->m_szIsMatch, sfieldvalue(szField, ",", 2));
		strcpy(pstExpress->m_szNotMatch, sfieldvalue(szField, ",", 3));
	}
	else if(!strncmp(s, "atol($$", 7))
	{
		pstExpress->m_lField = 1;
		pstExpress->m_lConst = EXP_CONST_STRTOL;
		strcpy(pstExpress->m_szResult, sfieldvalue(szField, "", 1));
	}
	else if(!strncmp(s, "strcmp($$", 9))
	{
		pstExpress->m_lField = 2;
		pstExpress->m_lConst = EXP_CONST_STRCMP;
		strcpy(pstExpress->m_szField[0], sfieldvalue(szField, ",", 1));
		strcpy(pstExpress->m_szField[1], sfieldvalue(szField, ",", 1));
		strcpy(pstExpress->m_szIsMatch, "0");
		strcpy(pstExpress->m_szNotMatch, "1");
	}
	else if(!strncmp(s, "strcpy($$", 9))
	{
		pstExpress->m_lField = 2;
		pstExpress->m_lConst = EXP_CONST_STRCPY;
		strcpy(pstExpress->m_szField[0], sfieldvalue(szField, ",", 1));
		strcpy(pstExpress->m_szField[1], sfieldvalue(szField, ",", 1));
	}
	else if(!strncmp(s, "strcat($$", 9))
	{
		pstExpress->m_lField = 2;
		pstExpress->m_lConst = EXP_CONST_SUBSTR;
		strcpy(pstExpress->m_szField[0], sfieldvalue(szField, ",", 1));
		strcpy(pstExpress->m_szField[1], sfieldvalue(szField, ",", 1));
	}
	else if(!strncmp(s, "substr($$", 9))
	{
		pstExpress->m_lField = 2;
		pstExpress->m_lConst = EXP_CONST_SUBSTR;
		strcpy(pstExpress->m_szField[0], sfieldvalue(szField, ",", 1));
		strcpy(pstExpress->m_szField[1], sfieldvalue(szField, ",", 1));
		strcpy(pstExpress->m_szIsMatch, "0");
		strcpy(pstExpress->m_szNotMatch, "1");
	}
	else
	{
		*plRet = RC_FAIL;
		return *plRet;
	}

	return RC_SUCC;
}



long	lPickupFunc(char *s)
{
	long	i, j, skip;
	char	*p = NULL, szCon[TARGET_VALUE_LEN];

	memset(szCon, 0, sizeof(szCon));
	if(!s || 0 == (j = strlen(s)))	return RC_SUCC;

	if(strncmp(s, "if(", 3) && strncmp(s, "strcmp(", 7) && strncmp(s, "strcpy(", 7) && 
		strncmp(s, "strcat(", 7) && strncmp(s, "atol(", 5) && strncmp(s, "substr(", 7))
		return RC_FAIL;
	
//  strcmp(strcat(fds,fds),strcat(fdsg,fdsgds))
//  strcmp(fds,fdsgds)

	for(i = 0, skip = 0, p = strstr(s, "(") + 1; i < (j - (p - s)) && p; i ++)
	{
		if(p[i] == '(')
			skip ++;
		else if(p[i] == ')')
		{
			if(0 == skip)
			{
				memcpy(szCon, p, MIN(TARGET_VALUE_LEN, i));
				fprintf(stderr, "RESULT:=======%s===\n", szCon);
				return RC_SUCC;
			}
			else if(-1 == --skip)
				break;
		}
	}

	memcpy(szCon, p, MIN(TARGET_VALUE_LEN, i));
	fprintf(stderr, "NEXT:=======%s===\n", szCon);
	return lPickupFunc(szCon);
}


long	lPraseExpFunc(char *s)
{
	long	i = 0;
	char	*p = NULL;
	Express	*pstExpress = NULL;
	char	szFiled[TARGET_VALUE_LEN];
	
	fprintf(stdout, "函数:[%s]\n", s);

	memset(szFiled, 0, sizeof(szFiled));
	if(!strcmp(s, "__RUN__"))
	{
		if(MAX_EXPRESS < g_stFlow.m_lExp)
			return RC_FAIL;

		pstExpress = &g_stFlow.m_stExp[g_stFlow.m_lExp ++];
		pstExpress->m_lConst = EXP_ALWAY_RUNNIG;
		pstExpress->m_szResult[0] = 0x30;
		return RC_SUCC;
	}
	else if(strncmp(s, "if($$", 5) && strncmp(s, "strcmp($$", 9) && strncmp(s, "strcpy($$", 9) 
		&& strncmp(s, "strcat($$", 9) && strncmp(s, "atol($$", 7) && strncmp(s, "substr($$", 9))
	{
		if(MAX_EXPRESS < g_stFlow.m_lExp)
			return RC_FAIL;

		pstExpress = &g_stFlow.m_stExp[g_stFlow.m_lExp ++];
		pstExpress->m_lConst = EXP_CONST_STRING;
		strncpy(pstExpress->m_szResult, s, sizeof(pstExpress->m_szResult));
		return RC_SUCC;
	}

fprintf(stdout, "==========================\n");
	lPickupFunc(s);
return RC_SUCC;
	for(i = 0; 0 < strlen(strimfield(s)); i ++)
	{
		;
	}

//	fprintf(stdout, "[%s]\n", sPickupFunc(s, szFiled, sizeof(szFiled)));
//	fprintf(stdout, "[%d]\n", sPickupFunc(s, NULL, NULL));
//	fprintf(stdout, "[%s]\n", sPickupFiled(s, szFiled));

//	return lPaseExpComb(s);
	return RC_SUCC;
}

/****************************************************************************************

****************************************************************************************/
int     main(int argc, char *argv[])
{
	long	i, j, n, m;
	char	*pvFun[MAX_EXPRESS];
//	char	*p = "strcmp(strcat(strcpy($$id, $$name), $$string),\"000  000\");__RUN__;strcat($$idx,\"testse\")";
//	char	*p = "strcmp(strcat(strcpy($$id, $$name), strcat($$string, $$name)),\"000  000\");"
//				"strcmp(strcat(strcpy($$id, $$name), $$string),\"000  000\");__RUN__;strcat($$idx,\"testse\")";

	char	szExpress[256], szTest[300] = "   strcmp(   strcat(strcpy($$id, $$name), strcat($$string, $$name    )),\"000  000\");";

	lInitRunTest(basename(argv[0]));


	for(i = 0, n = lGetValidNum(szTest, ";"); i < n; i ++)
	{
		memset(szExpress, 0, sizeof(szExpress));
		strncpy(szExpress, sGetValueByIdx(szTest, ";", i + 1), sizeof(szExpress));
		strimcrlf(szExpress);	
		sltrim(szExpress);
		srtrim(szExpress);
		if(!sTrimLegal(szExpress))
		{
			fprintf(stderr, "函数不合法[%s]\n", szExpress);
			return RC_FAIL;
		}

		lPraseExpFunc(szExpress);
	}

    return RC_SUCC;
}

/****************************************************************************************
	code end
****************************************************************************************/
