/**************************************************************************************************
    文 件 名：demo.pc
    代码作者：DeffPuzzL
    编写版本：
    创建日期：2016-07-14
    功能描述：demo实现业务模块
 **************************************************************************************************/
#include    "vdata_load.h"
#include    "algo.h"

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
#include    "tbl_order_succ.h"
EXEC SQL END DECLARE SECTION;

/**************************************************************************************************
    方法定义
 **************************************************************************************************/
CLoad::stEvent CLoad::m_stEvent[] =
{
    {"unload",            &CLoad::vUnloadTxn },
    {"load",           	  &CLoad::vLoadTxn },
    { "", NULL }
};

/**************************************************************************************************
    函 数 名：CLoad()
    功能描述：构造函数
    返回说明：
 **************************************************************************************************/
CLoad::CLoad()
{

}

/**************************************************************************************************
    函 数 名：~CLoad()
    功能描述：析构函数
    返回说明：
 **************************************************************************************************/
CLoad::~CLoad()
{


}

/**************************************************************************************************
    函 数 名：lRunObject(char* in_szClass, char* in_szAction)
    功能描述：运行类中的方法
    返回说明：
        RC_SUCC         --成功
        RC_FAIL         --失败
 **************************************************************************************************/
long    CLoad::lRunObject(char *in_szClass, char *in_szAction)
{
    int     i = 0;
    char    *p, szAction[256];

    memset(szAction, 0, sizeof(szAction));

    if ((p = strstr(in_szAction, "__")) != NULL)
    {
        strncpy(szAction, in_szAction, p - in_szAction);
    }
    else
    {
        strcpy(szAction, in_szAction);
    }

    while (0 != strcmp(m_stEvent[i].m_szName, ""))
    {
        if (0 == strcmp(m_stEvent[i].m_szName, szAction))
        {
            (this->*m_stEvent[i].m_pEvent)();
            return RC_SUCC;
        }

        i++;
    }

    SYSError(RET_SYSTEM, "组件(%s)的事件(%s)没注册", in_szClass, in_szAction);
    return RC_FAIL;
}

/**************************************************************************************************
    函 数 名：vUnloadTxn()
    功能描述：
    返回说明：
        无
 **************************************************************************************************/
void    CLoad::vUnloadTxn()
{
	EXEC SQL BEGIN DECLARE SECTION;
	TOrderSucc	stOrder;
	char		szDone[2], szFile[512];
	char		szDate[9], szNum[5], szFlag[2];
	EXEC SQL END DECLARE SECTION;
	long		lCount = 0;
	FILE		*fp = NULL;
    GCts   		*pstCts = (GCts *)pGetGloble();

	memset(szNum, 0, sizeof(szNum));
	memset(szDate, 0, sizeof(szDate));
	memset(szFile, 0, sizeof(szFile));
	memset(szFlag, 0, sizeof(szFlag));
	memset(szDone, 0, sizeof(szDone));
	memset(&stOrder, 0, sizeof(TOrderSucc));
	IBPgetstring("BAT_InNum", szNum, "批次编号");
	IBPgetstring("BAT_SettleDate", szDate, "清算日期");
    if(IBPIserr())
        return ;

	szFlag[0] = EXPORT_TXN_NULL;
	szDone[0] = EXPORT_TXN_DONE;
    snprintf(szFile, sizeof(szFile), "%s/VDATA%s_%s.txt", getenv("POOL_FILE_PATH"), szDate, szNum);
    if (!(fp = fopen(szFile, "wb")))
    {
        SYSError(RET_SYSTEM, "打开文件(%s)失败, err:(%d)(%s)", szFile, errno, strerror(errno));
        return ;
    }

    IBPrace("开始导出交易流水(%s)批次(%s), 导出文件:%s", szDate, szNum, szFile);

	if(RC_SUCC != lDbsConnect(DBS_TXN))
	{
		SYSError(RET_DATABASE, "连接代扣系统数据库失败, err:(%d)(%s)", SQLCODE, sDbsError())
		return ;
	}

	EXEC SQL DECLARE Cur_payment_order CURSOR FOR 
		SELECT ID, SEQ_ID, DISC_CYCLE, CHANNEL_ID, BANK_CODE, PAY_TYPE, 
			TO_CHAR(TRANS_DATE, 'YYYYMMDD'), TO_CHAR(TRANS_DATE, 'HHMISS'),
			AMOUNT, BANK_CARD_NO, USER_NAME, BANK_ACC_TYPE, BANK_FULL_NAME, 
			BANK_BRANCH_NAME, BANK_AREACODE, CNAPS_NO, CNAPS_BANKNO, CURRENCY, 
			REMARK, STATUS, BANK_RESPCODE, BANK_RESPMSG, VID_RESPCODE, VID_RESPMSG,
			EXT_PROPERTIES, CUSTOMER_CARD_TYPE, APP_CODE, BRH_CODE, MERT_ID, 
			MERT_NAME, CERT_TYPE, CERT_NO, MOBILE_NO, ORDER_ID, PRODUCT_CODE, 
			PRODUCT_NAME, PAY_KIND, BANK_SEQ_ID, BATCH_SEQ_ID
	FROM TBL_DKPAYMENT_ORDER where TO_CHAR(TRANS_DATE, 'YYYYMMDD') < :szDate 
		AND SUBSTR(CHECK_STATUS, 2, 1) = :szFlag;

	EXEC SQL OPEN Cur_payment_order;
    if(SQLCODE)
    {
        fclose(fp);
        SYSError(RET_DATABASE, "打开游标失败, err:(%d)(%s)", SQLCODE, sDbsError());
        return ;
    }

    while (1)
    {
		memset(&stOrder, 0, sizeof(TOrderSucc));
        EXEC SQL FETCH Cur_payment_order INTO
        	:stOrder.id, :stOrder.seq_order, :stOrder.disc_cycle, :stOrder.channel_no,
            :stOrder.bank_code, :stOrder.pay_type, :stOrder.tx_date, :stOrder.tx_time, 
			:stOrder.tx_amt, :stOrder.bank_card_no, :stOrder.user_name, :stOrder.bank_acc_type,
            :stOrder.bank_full_name, :stOrder.bank_branch_name, :stOrder.bank_areacode,
            :stOrder.cnaps_no, :stOrder.cnaps_bankno, :stOrder.currency, :stOrder.remark,
            :stOrder.status, :stOrder.bank_respcode, :stOrder.bank_respmsg, :stOrder.vid_respcode, 
			:stOrder.vid_respmsg, :stOrder.ext_properties, :stOrder.card_type, :stOrder.app_code, 
			:stOrder.brh_code, :stOrder.mert_no, :stOrder.mert_nm, :stOrder.cert_type, 
			:stOrder.cert_no, :stOrder.mobile_no, :stOrder.order_id, :stOrder.product_code, 
			:stOrder.product_name, :stOrder.pay_kind, :stOrder.bank_seqno, :stOrder.batch_seqno;
        if(SQLERR)
        {
            SYSError(RET_DATABASE, "导出代扣流水失败, err:(%d)(%s)", SQLCODE, sDbsError());
            break;
        }
        if(SQLNOTFOUND)
            break;

		++ lCount;
		sTrimRight(stOrder.id);
		sTrimRight(stOrder.seq_order);
		sTrimRight(stOrder.bank_code);
		sTrimRight(stOrder.pay_type);
		sTrimRight(stOrder.tx_date);
		sTrimRight(stOrder.tx_time);
		sTrimRight(stOrder.bank_card_no);
		sTrimRight(stOrder.user_name);
		sTrimRight(stOrder.bank_acc_type);
		sTrimRight(stOrder.bank_full_name);
		sTrimRight(stOrder.bank_branch_name);
		sTrimRight(stOrder.bank_areacode);
		sTrimRight(stOrder.cnaps_no);
		sTrimRight(stOrder.cnaps_bankno);
		sTrimRight(stOrder.currency);
		sTrimRight(stOrder.remark);
		sTrimRight(stOrder.status);
		sTrimRight(stOrder.bank_respcode);
		sTrimRight(stOrder.bank_respmsg);
		sTrimRight(stOrder.vid_respcode);
		sTrimRight(stOrder.vid_respmsg);
		sTrimRight(stOrder.ext_properties);
		sTrimRight(stOrder.app_code);
		sTrimRight(stOrder.brh_code);
		sTrimRight(stOrder.mert_no);
		sTrimRight(stOrder.mert_nm);
		sTrimRight(stOrder.cert_no);
		sTrimRight(stOrder.mobile_no);
		sTrimRight(stOrder.order_id);
		sTrimRight(stOrder.bank_seqno);
		sTrimRight(stOrder.batch_seqno);
		sTrimRight(stOrder.product_code);
		sTrimRight(stOrder.product_name);

		fwrite(&stOrder, sizeof(TOrderSucc), 1, fp);
	}
	EXEC SQL CLOSE Cur_payment_order;
	fclose(fp);

	EXEC SQL UPDATE tbl_dkpayment_order SET
		CHECK_STATUS = SUBSTR(CHECK_STATUS, 1, 1) || :szDone
	WHERE TO_CHAR(TRANS_DATE, 'YYYYMMDD') < :szDate 
		AND substr(CHECK_STATUS, 2, 1) = :szFlag;
    if(SQL_UD_ERR)
    {
    	SYSError(RET_DATABASE, "更新流水导出标识失败, err:(%d)(%s)", SQLCODE, sDbsError());
        EXEC SQL ROLLBACK WORK;
		vDbsDisconnect();
        return ;
    }

	EXEC SQL COMMIT WORK;
	vDbsDisconnect();

    IBPrace("导出交易流水(%s)批次(%s), 导出流水(%ld)条", szDate, szNum, lCount);

	return ;
}


/*************************************************************************************************
    组件函数
**************************************************************************************************/
void    CLoad::vLoadTxn()
{
	EXEC SQL BEGIN DECLARE SECTION;
	TOrderSucc	stOrder;
	char		szDate[9], szNum[5], szFile[512];
	EXEC SQL END DECLARE SECTION;
	long		lCount = 0;
	FILE		*fp = NULL;
    GCts   		*pstCts = (GCts *)pGetGloble();

	memset(szNum, 0, sizeof(szNum));
	memset(szFile, 0, sizeof(szFile));
	memset(szDate, 0, sizeof(szDate));
	memset(&stOrder, 0, sizeof(TOrderSucc));
	IBPgetstring("BAT_InNum", szNum, "批次编号");
	IBPgetstring("BAT_SettleDate", szDate, "清算日期");
    if(IBPIserr())
        return ;

    snprintf(szFile, sizeof(szFile), "%s/VDATA%s_%s.txt", getenv("POOL_FILE_PATH"), szDate, szNum);
    if(NULL == (fp = fopen(szFile, "rb")))
    {
        SYSError(RET_SYSTEM, "打开文件(%s)失败, err:(%d)(%s)", szFile, errno, strerror(errno));
        return ;
    }

    IBPrace("开始导入交易流水(%s)批次(%s)文件:%s", szDate, szNum, szFile);

	if(RC_SUCC != lDbsConnect(DBS_BATCH))
	{
		SYSError(RET_DATABASE, "连接代扣系统数据库失败, err:(%d)(%s)", SQLCODE, sDbsError())
		return ;
	}

    while(fread((char *)&stOrder, sizeof(TOrderSucc), 1, fp))
    {
		strncpy(stOrder.create_time, sGetCurrentTime(), sizeof(stOrder.create_time));

        if((!strcmp(stOrder.status, "success")) && (!strcmp(stOrder.pay_type, "ptdk")))
		{
			stOrder.result_flag[0] = TXN_SUCC_INIT;
			snprintf(stOrder.cup_key, sizeof(stOrder.cup_key), "%s%s", stOrder.channel_no, stOrder.seq_order);
		}
		else
			stOrder.result_flag[0] = TXN_SUCC_REVERSED;

        EXEC SQL INSERT INTO TBL_ORDER_SUCC VALUES (:stOrder);
        if(SQLCODE)
        {
			fclose(fp);
        	SYSError(RET_DATABASE, "(%s)(%s)新增流水(%s)失败, err:(%d)(%s)", szDate, szNum, 
				stOrder.id, SQLCODE, sDbsError());
            EXEC SQL ROLLBACK WORK;
			vDbsDisconnect();
			return ;
		}

        if(0 == ++ lCount % 2000)
            EXEC SQL COMMIT WORK;
	}
	fclose(fp);
    EXEC SQL COMMIT WORK;
	vDbsDisconnect();

    IBPrace("开始导入文件(%s)流水笔数:%d", szFile, lCount);

    return ;
}

/*************************************************************************************************
    code end
**************************************************************************************************/
